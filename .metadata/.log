!SESSION 2016-12-12 13:20:03.207 -----------------------------------------------
eclipse.buildId=4.6.1.M20160907-1200
java.version=1.8.0_111
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2016-12-12 13:22:28.014
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2016-12-12 13:22:28.014
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.014
!MESSAGE Software being installed: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.014
!MESSAGE Missing requirement: AspectJ 1.7.3.20130613144500-a (org.aspectj.ajde 1.7.3.20130613144500-a) requires 'bundle org.eclipse.core.runtime.compatibility 0.0.0' but it could not be found
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 13:22:28.014
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.014
!MESSAGE From: AspectJ Compiler 1.7.3.20130613144500-a (org.aspectj.feature.group 1.7.3.20130613144500-a)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.014
!MESSAGE To: org.aspectj.ajde [1.7.3.20130613144500-a]
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 13:22:28.014
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.014
!MESSAGE From: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.014
!MESSAGE To: org.aspectj.feature.group [1.7.3.20130613144500-a]

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2016-12-12 13:22:28.028
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2016-12-12 13:22:28.028
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.028
!MESSAGE Software being installed: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.028
!MESSAGE Missing requirement: AspectJ 1.7.3.20130613144500-a (org.aspectj.ajde 1.7.3.20130613144500-a) requires 'bundle org.eclipse.core.runtime.compatibility 0.0.0' but it could not be found
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 13:22:28.028
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.028
!MESSAGE From: AspectJ Compiler 1.7.3.20130613144500-a (org.aspectj.feature.group 1.7.3.20130613144500-a)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.028
!MESSAGE To: org.aspectj.ajde [1.7.3.20130613144500-a]
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 13:22:28.028
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.028
!MESSAGE From: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.028
!MESSAGE To: org.aspectj.feature.group [1.7.3.20130613144500-a]

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2016-12-12 13:22:28.041
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2016-12-12 13:22:28.041
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.041
!MESSAGE Software being installed: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.041
!MESSAGE Missing requirement: AspectJ 1.7.3.20130613144500-a (org.aspectj.ajde 1.7.3.20130613144500-a) requires 'bundle org.eclipse.core.runtime.compatibility 0.0.0' but it could not be found
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 13:22:28.041
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.041
!MESSAGE From: AspectJ Compiler 1.7.3.20130613144500-a (org.aspectj.feature.group 1.7.3.20130613144500-a)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.041
!MESSAGE To: org.aspectj.ajde [1.7.3.20130613144500-a]
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 13:22:28.041
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.041
!MESSAGE From: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.041
!MESSAGE To: org.aspectj.feature.group [1.7.3.20130613144500-a]

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2016-12-12 13:22:28.042
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2016-12-12 13:22:28.042
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.042
!MESSAGE Software being installed: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.042
!MESSAGE Missing requirement: AspectJ 1.7.3.20130613144500-a (org.aspectj.ajde 1.7.3.20130613144500-a) requires 'bundle org.eclipse.core.runtime.compatibility 0.0.0' but it could not be found
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 13:22:28.042
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.042
!MESSAGE From: AspectJ Compiler 1.7.3.20130613144500-a (org.aspectj.feature.group 1.7.3.20130613144500-a)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.042
!MESSAGE To: org.aspectj.ajde [1.7.3.20130613144500-a]
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 13:22:28.042
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.042
!MESSAGE From: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 13:22:28.042
!MESSAGE To: org.aspectj.feature.group [1.7.3.20130613144500-a]
!SESSION 2016-12-12 13:33:05.329 -----------------------------------------------
eclipse.buildId=4.6.1.M20160907-1200
java.version=1.8.0_111
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=fr_FR

!ENTRY org.eclipse.osgi 4 0 2016-12-12 13:33:05.479
!MESSAGE error loading hook: org.eclipse.equinox.weaving.hooks.WeavingHook
!STACK 0
java.lang.NoClassDefFoundError: org/eclipse/osgi/baseadaptor/HookConfigurator
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:73)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:368)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:362)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:361)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:73)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:368)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:362)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:361)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at org.eclipse.osgi.internal.hookregistry.HookRegistry.loadConfigurators(HookRegistry.java:185)
	at org.eclipse.osgi.internal.hookregistry.HookRegistry.initialize(HookRegistry.java:106)
	at org.eclipse.osgi.internal.framework.EquinoxContainer.<init>(EquinoxContainer.java:64)
	at org.eclipse.osgi.launch.Equinox.<init>(Equinox.java:31)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.startup(EclipseStarter.java:303)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:239)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)
Caused by: java.lang.ClassNotFoundException: org.eclipse.osgi.baseadaptor.HookConfigurator
	at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	... 38 more

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2016-12-12 14:46:42.609
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2016-12-12 14:46:42.609
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:46:42.609
!MESSAGE Software being installed: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:46:42.609
!MESSAGE Missing requirement: AspectJ 1.7.3.20130613144500-a (org.aspectj.ajde 1.7.3.20130613144500-a) requires 'bundle org.eclipse.core.runtime.compatibility 0.0.0' but it could not be found
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 14:46:42.609
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:46:42.609
!MESSAGE From: AspectJ Compiler 1.7.3.20130613144500-a (org.aspectj.feature.group 1.7.3.20130613144500-a)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:46:42.609
!MESSAGE To: org.aspectj.ajde [1.7.3.20130613144500-a]
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 14:46:42.609
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:46:42.609
!MESSAGE From: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:46:42.609
!MESSAGE To: org.aspectj.feature.group [1.7.3.20130613144500-a]

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2016-12-12 14:46:42.621
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2016-12-12 14:46:42.622
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:46:42.622
!MESSAGE Software being installed: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:46:42.622
!MESSAGE Missing requirement: AspectJ 1.7.3.20130613144500-a (org.aspectj.ajde 1.7.3.20130613144500-a) requires 'bundle org.eclipse.core.runtime.compatibility 0.0.0' but it could not be found
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 14:46:42.622
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:46:42.622
!MESSAGE From: AspectJ Compiler 1.7.3.20130613144500-a (org.aspectj.feature.group 1.7.3.20130613144500-a)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:46:42.622
!MESSAGE To: org.aspectj.ajde [1.7.3.20130613144500-a]
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 14:46:42.622
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:46:42.622
!MESSAGE From: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:46:42.622
!MESSAGE To: org.aspectj.feature.group [1.7.3.20130613144500-a]

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2016-12-12 14:47:45.399
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2016-12-12 14:47:45.399
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:47:45.399
!MESSAGE Software being installed: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:47:45.399
!MESSAGE Missing requirement: AspectJ 1.7.3.20130613144500-a (org.aspectj.ajde 1.7.3.20130613144500-a) requires 'bundle org.eclipse.core.runtime.compatibility 0.0.0' but it could not be found
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 14:47:45.399
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:47:45.399
!MESSAGE From: AspectJ Compiler 1.7.3.20130613144500-a (org.aspectj.feature.group 1.7.3.20130613144500-a)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:47:45.399
!MESSAGE To: org.aspectj.ajde [1.7.3.20130613144500-a]
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 14:47:45.399
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:47:45.399
!MESSAGE From: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:47:45.399
!MESSAGE To: org.aspectj.feature.group [1.7.3.20130613144500-a]

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2016-12-12 14:47:45.400
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2016-12-12 14:47:45.400
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:47:45.400
!MESSAGE Software being installed: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:47:45.400
!MESSAGE Missing requirement: AspectJ 1.7.3.20130613144500-a (org.aspectj.ajde 1.7.3.20130613144500-a) requires 'bundle org.eclipse.core.runtime.compatibility 0.0.0' but it could not be found
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 14:47:45.400
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:47:45.400
!MESSAGE From: AspectJ Compiler 1.7.3.20130613144500-a (org.aspectj.feature.group 1.7.3.20130613144500-a)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:47:45.400
!MESSAGE To: org.aspectj.ajde [1.7.3.20130613144500-a]
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2016-12-12 14:47:45.400
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:47:45.400
!MESSAGE From: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:47:45.400
!MESSAGE To: org.aspectj.feature.group [1.7.3.20130613144500-a]

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2016-12-12 14:49:59.988
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.operations 2 10001 2016-12-12 14:49:59.988
!MESSAGE Your original request has been modified.
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.988
!MESSAGE "Cross References tool (XRef)" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.988
!MESSAGE "Eclipse Weaving Service Feature" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.988
!MESSAGE "Cross References Tool Source Code" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.988
!MESSAGE "AspectJ Development Tools (AJDT) Source Code" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.988
!MESSAGE "Equinox Weaving SDK" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.988
!MESSAGE "Eclipse Weaving Service Source Code" will be ignored because a newer version is already installed. 
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2016-12-12 14:49:59.988
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:49:59.988
!MESSAGE Software being installed: AspectJ Development Tools 2.1.1.e35x-release-20101021-0900 (org.eclipse.ajdt.feature.group 2.1.1.e35x-release-20101021-0900)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:49:59.988
!MESSAGE Missing requirement: AspectJ Development Tools 2.1.1.e35x-release-20101021-0900 (org.eclipse.ajdt.feature.group 2.1.1.e35x-release-20101021-0900) requires 'org.eclipse.core.resources [3.5.0,3.6.0)' but it could not be found

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2016-12-12 14:49:59.989
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.operations 2 10001 2016-12-12 14:49:59.989
!MESSAGE Your original request has been modified.
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.989
!MESSAGE "Cross References tool (XRef)" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.989
!MESSAGE "Eclipse Weaving Service Feature" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.989
!MESSAGE "Cross References Tool Source Code" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.989
!MESSAGE "AspectJ Development Tools (AJDT) Source Code" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.989
!MESSAGE "Equinox Weaving SDK" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.989
!MESSAGE "Eclipse Weaving Service Source Code" will be ignored because a newer version is already installed. 
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2016-12-12 14:49:59.989
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:49:59.989
!MESSAGE Software being installed: AspectJ Development Tools 2.1.1.e35x-release-20101021-0900 (org.eclipse.ajdt.feature.group 2.1.1.e35x-release-20101021-0900)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:49:59.989
!MESSAGE Missing requirement: AspectJ Development Tools 2.1.1.e35x-release-20101021-0900 (org.eclipse.ajdt.feature.group 2.1.1.e35x-release-20101021-0900) requires 'org.eclipse.core.resources [3.5.0,3.6.0)' but it could not be found

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2016-12-12 14:49:59.995
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.operations 2 10001 2016-12-12 14:49:59.995
!MESSAGE Your original request has been modified.
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.995
!MESSAGE "Cross References tool (XRef)" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.995
!MESSAGE "Eclipse Weaving Service Feature" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.995
!MESSAGE "Cross References Tool Source Code" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.995
!MESSAGE "AspectJ Development Tools (AJDT) Source Code" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.995
!MESSAGE "Equinox Weaving SDK" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.995
!MESSAGE "Eclipse Weaving Service Source Code" will be ignored because a newer version is already installed. 
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2016-12-12 14:49:59.995
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:49:59.995
!MESSAGE Software being installed: AspectJ Development Tools 2.1.1.e35x-release-20101021-0900 (org.eclipse.ajdt.feature.group 2.1.1.e35x-release-20101021-0900)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:49:59.996
!MESSAGE Missing requirement: AspectJ Development Tools 2.1.1.e35x-release-20101021-0900 (org.eclipse.ajdt.feature.group 2.1.1.e35x-release-20101021-0900) requires 'org.eclipse.core.resources [3.5.0,3.6.0)' but it could not be found

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2016-12-12 14:49:59.996
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.operations 2 10001 2016-12-12 14:49:59.996
!MESSAGE Your original request has been modified.
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.996
!MESSAGE "Cross References tool (XRef)" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.996
!MESSAGE "Eclipse Weaving Service Feature" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.996
!MESSAGE "Cross References Tool Source Code" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.996
!MESSAGE "AspectJ Development Tools (AJDT) Source Code" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.996
!MESSAGE "Equinox Weaving SDK" will be ignored because a newer version is already installed. 
!SUBENTRY 2 org.eclipse.equinox.p2.operations 2 10004 2016-12-12 14:49:59.996
!MESSAGE "Eclipse Weaving Service Source Code" will be ignored because a newer version is already installed. 
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2016-12-12 14:49:59.996
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:49:59.996
!MESSAGE Software being installed: AspectJ Development Tools 2.1.1.e35x-release-20101021-0900 (org.eclipse.ajdt.feature.group 2.1.1.e35x-release-20101021-0900)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2016-12-12 14:49:59.996
!MESSAGE Missing requirement: AspectJ Development Tools 2.1.1.e35x-release-20101021-0900 (org.eclipse.ajdt.feature.group 2.1.1.e35x-release-20101021-0900) requires 'org.eclipse.core.resources [3.5.0,3.6.0)' but it could not be found
!SESSION 2016-12-12 14:52:00.471 -----------------------------------------------
eclipse.buildId=4.6.1.M20160907-1200
java.version=1.8.0_111
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -data file:/home/valentin/workspace/ -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.e4.ui.workbench 4 0 2016-12-12 14:52:14.009
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListView.createPartControl(TaskListView.java:867)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:150)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityView.createPartControl(CompatibilityView.java:143)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:340)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:966)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:931)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:151)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:375)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:294)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:162)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:105)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:74)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:56)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:129)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:975)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:651)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:536)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:520)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:70)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:975)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:651)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1317)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:669)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.createElement(PartServiceImpl.java:1253)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.showPart(PartServiceImpl.java:1218)
	at org.eclipse.ui.internal.WorkbenchPage.showPart(WorkbenchPage.java:1309)
	at org.eclipse.ui.internal.WorkbenchPage.busyShowView(WorkbenchPage.java:1274)
	at org.eclipse.ui.internal.WorkbenchPage$12.run(WorkbenchPage.java:4316)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ui.internal.WorkbenchPage.showView(WorkbenchPage.java:4312)
	at org.eclipse.ui.internal.ide.IDEWorkbenchPlugin$1.run(IDEWorkbenchPlugin.java:367)
	at org.eclipse.swt.widgets.Display.timerProc(Display.java:5144)
	at org.eclipse.swt.internal.gtk.OS._gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.internal.gtk.OS.gtk_main_iteration_do(OS.java:9545)
	at org.eclipse.swt.widgets.ProgressBar.updateBar(ProgressBar.java:304)
	at org.eclipse.swt.widgets.ProgressBar.setSelection(ProgressBar.java:258)
	at org.eclipse.jface.dialogs.ProgressIndicator.worked(ProgressIndicator.java:140)
	at org.eclipse.jface.wizard.ProgressMonitorPart.internalWorked(ProgressMonitorPart.java:282)
	at org.eclipse.ui.splash.BasicSplashHandler$AbsolutePositionProgressMonitorPart.access$2(BasicSplashHandler.java:1)
	at org.eclipse.ui.splash.BasicSplashHandler$AbsolutePositionProgressMonitorPart$3.run(BasicSplashHandler.java:110)
	at org.eclipse.ui.splash.BasicSplashHandler.updateUI(BasicSplashHandler.java:277)
	at org.eclipse.ui.splash.BasicSplashHandler.access$0(BasicSplashHandler.java:269)
	at org.eclipse.ui.splash.BasicSplashHandler$AbsolutePositionProgressMonitorPart.internalWorked(BasicSplashHandler.java:103)
	at org.eclipse.jface.wizard.ProgressMonitorPart.worked(ProgressMonitorPart.java:370)
	at org.eclipse.ui.internal.Workbench$StartupProgressBundleListener.bundleChanged(Workbench.java:333)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.dispatchEvent(BundleContextImpl.java:903)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.osgi.internal.framework.EquinoxEventPublisher.publishBundleEventPrivileged(EquinoxEventPublisher.java:213)
	at org.eclipse.osgi.internal.framework.EquinoxEventPublisher.publishBundleEvent(EquinoxEventPublisher.java:120)
	at org.eclipse.osgi.internal.framework.EquinoxEventPublisher.publishBundleEvent(EquinoxEventPublisher.java:112)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor.publishModuleEvent(EquinoxContainerAdaptor.java:156)
	at org.eclipse.osgi.container.Module.publishEvent(Module.java:476)
	at org.eclipse.osgi.container.Module.start(Module.java:467)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:470)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:529)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:325)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:423)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:372)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:364)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:161)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:564)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:174)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:905)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:55)
	at org.eclipse.mylyn.commons.core.ExtensionPointReader.readElement(ExtensionPointReader.java:189)
	at org.eclipse.mylyn.commons.core.ExtensionPointReader.read(ExtensionPointReader.java:151)
	at org.eclipse.mylyn.internal.commons.repositories.core.LocationService$LocationServiceInitializer.<clinit>(LocationService.java:40)
	at org.eclipse.mylyn.internal.commons.repositories.core.LocationService.getDefault(LocationService.java:63)
	at org.eclipse.mylyn.tasks.core.TaskRepository.<init>(TaskRepository.java:208)
	at org.eclipse.mylyn.tasks.core.TaskRepository.<init>(TaskRepository.java:232)
	at org.eclipse.mylyn.tasks.core.TaskRepository.<init>(TaskRepository.java:211)
	at org.eclipse.mylyn.internal.tasks.core.SaxRepositoriesContentHandler.handleRepositoryElement(SaxRepositoriesContentHandler.java:70)
	at org.eclipse.mylyn.internal.tasks.core.SaxRepositoriesContentHandler.startElement(SaxRepositoriesContentHandler.java:46)
	at org.apache.xerces.parsers.AbstractSAXParser.startElement(Unknown Source)
	at org.apache.xerces.impl.XMLNSDocumentScannerImpl.scanStartElement(Unknown Source)
	at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source)
	at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source)
	at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)
	at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)
	at org.apache.xerces.parsers.XMLParser.parse(Unknown Source)
	at org.apache.xerces.parsers.AbstractSAXParser.parse(Unknown Source)
	at org.eclipse.mylyn.internal.tasks.core.TaskRepositoriesExternalizer.readRepositoriesFromXML(TaskRepositoriesExternalizer.java:122)
	at org.eclipse.mylyn.internal.tasks.core.TaskRepositoryManager.loadRepositories(TaskRepositoryManager.java:338)
	at org.eclipse.mylyn.internal.tasks.core.TaskRepositoryManager.readRepositories(TaskRepositoryManager.java:314)
	at org.eclipse.mylyn.internal.tasks.core.RepositoryExternalizationParticipant.load(RepositoryExternalizationParticipant.java:69)
	at org.eclipse.mylyn.internal.tasks.core.externalization.AbstractExternalizationParticipant.performLoad(AbstractExternalizationParticipant.java:83)
	at org.eclipse.mylyn.internal.tasks.core.externalization.AbstractExternalizationParticipant.execute(AbstractExternalizationParticipant.java:73)
	at org.eclipse.mylyn.internal.tasks.core.externalization.ExternalizationManager$1.run(ExternalizationManager.java:117)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.mylyn.internal.tasks.core.externalization.ExternalizationManager.load(ExternalizationManager.java:106)
	at org.eclipse.mylyn.internal.tasks.core.externalization.ExternalizationManager.load(ExternalizationManager.java:84)
	at org.eclipse.mylyn.internal.tasks.ui.TasksUiPlugin.initializeDataSources(TasksUiPlugin.java:932)
	at org.eclipse.mylyn.internal.tasks.ui.TasksUiPlugin.start(TasksUiPlugin.java:620)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:774)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:724)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:932)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:309)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:470)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:529)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:325)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:423)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:372)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:364)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:161)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:564)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:174)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:905)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:55)
	at org.eclipse.core.internal.expressions.PropertyTesterDescriptor.instantiate(PropertyTesterDescriptor.java:96)
	at org.eclipse.core.internal.expressions.TypeExtension.findTypeExtender(TypeExtension.java:97)
	at org.eclipse.core.internal.expressions.TypeExtension.findTypeExtender(TypeExtension.java:130)
	at org.eclipse.core.internal.expressions.TypeExtension.findTypeExtender(TypeExtension.java:130)
	at org.eclipse.core.internal.expressions.TypeExtension.findTypeExtender(TypeExtension.java:130)
	at org.eclipse.core.internal.expressions.TypeExtensionManager.getProperty(TypeExtensionManager.java:119)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:97)
	at org.eclipse.e4.ui.internal.workbench.ContributionsAnalyzer.isVisible(ContributionsAnalyzer.java:257)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarContributionRecord.computeVisibility(ToolBarContributionRecord.java:127)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarContributionRecord.updateVisibility(ToolBarContributionRecord.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarManagerRenderer$5.changed(ToolBarManagerRenderer.java:479)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:114)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.runAndTrack(EclipseContext.java:324)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarManagerRenderer.processAddition(ToolBarManagerRenderer.java:471)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarManagerRenderer.generateContributions(ToolBarManagerRenderer.java:447)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarManagerRenderer.processContribution(ToolBarManagerRenderer.java:413)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarManagerRenderer.createWidget(ToolBarManagerRenderer.java:373)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:975)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:651)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeChildrenHandler(PartRenderingEngine.java:296)
	at sun.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:80)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:341)
	at org.eclipse.e4.ui.internal.workbench.ContributionsAnalyzer.processAddition(ContributionsAnalyzer.java:370)
	at org.eclipse.e4.ui.workbench.renderers.swt.TrimBarRenderer.addTrimContributions(TrimBarRenderer.java:171)
	at org.eclipse.e4.ui.workbench.renderers.swt.TrimBarRenderer.processContents(TrimBarRenderer.java:143)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeTopicToBeRendered(PartRenderingEngine.java:149)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:80)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:303)
	at org.eclipse.ui.internal.CoolBarToTrimManager.update(CoolBarToTrimManager.java:567)
	at org.eclipse.ui.internal.WorkbenchWindow.updateActionBars(WorkbenchWindow.java:2334)
	at org.eclipse.ui.internal.WorkbenchWindow.largeUpdateEnd(WorkbenchWindow.java:2387)
	at org.eclipse.ui.internal.Workbench.largeUpdateEnd(Workbench.java:3478)
	at org.eclipse.ui.internal.WorkbenchWindow.fillActionBars(WorkbenchWindow.java:2585)
	at org.eclipse.ui.internal.WorkbenchWindow.setup(WorkbenchWindow.java:667)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:966)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:151)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:118)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.inject(ContextInjectionFactory.java:73)
	at org.eclipse.ui.internal.Workbench.createWorkbenchWindow(Workbench.java:1525)
	at org.eclipse.ui.internal.Workbench.openWorkbenchWindow(Workbench.java:2653)
	at org.eclipse.ui.internal.Workbench.getWorkbenchPage(Workbench.java:2083)
	at org.eclipse.ui.internal.Workbench.setReference(Workbench.java:2131)
	at org.eclipse.ui.internal.Workbench.access$28(Workbench.java:2099)
	at org.eclipse.ui.internal.Workbench$35.handleEvent(Workbench.java:2021)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:5406)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.basic.impl.PartImpl.setContext(PartImpl.java:431)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:536)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:520)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:70)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:975)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:651)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1317)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:669)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:49)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:63)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:669)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:725)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1059)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:687)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)

!ENTRY org.eclipse.e4.ui.workbench 4 0 2016-12-12 14:52:14.014
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListView.dispose(TaskListView.java:456)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:156)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityView.createPartControl(CompatibilityView.java:143)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:340)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:966)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:931)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:151)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:375)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:294)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:162)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:105)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:74)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:56)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:129)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:975)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:651)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:536)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:520)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:70)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:975)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:651)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1317)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:669)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.createElement(PartServiceImpl.java:1253)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.showPart(PartServiceImpl.java:1218)
	at org.eclipse.ui.internal.WorkbenchPage.showPart(WorkbenchPage.java:1309)
	at org.eclipse.ui.internal.WorkbenchPage.busyShowView(WorkbenchPage.java:1274)
	at org.eclipse.ui.internal.WorkbenchPage$12.run(WorkbenchPage.java:4316)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ui.internal.WorkbenchPage.showView(WorkbenchPage.java:4312)
	at org.eclipse.ui.internal.ide.IDEWorkbenchPlugin$1.run(IDEWorkbenchPlugin.java:367)
	at org.eclipse.swt.widgets.Display.timerProc(Display.java:5144)
	at org.eclipse.swt.internal.gtk.OS._gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.internal.gtk.OS.gtk_main_iteration_do(OS.java:9545)
	at org.eclipse.swt.widgets.ProgressBar.updateBar(ProgressBar.java:304)
	at org.eclipse.swt.widgets.ProgressBar.setSelection(ProgressBar.java:258)
	at org.eclipse.jface.dialogs.ProgressIndicator.worked(ProgressIndicator.java:140)
	at org.eclipse.jface.wizard.ProgressMonitorPart.internalWorked(ProgressMonitorPart.java:282)
	at org.eclipse.ui.splash.BasicSplashHandler$AbsolutePositionProgressMonitorPart.access$2(BasicSplashHandler.java:1)
	at org.eclipse.ui.splash.BasicSplashHandler$AbsolutePositionProgressMonitorPart$3.run(BasicSplashHandler.java:110)
	at org.eclipse.ui.splash.BasicSplashHandler.updateUI(BasicSplashHandler.java:277)
	at org.eclipse.ui.splash.BasicSplashHandler.access$0(BasicSplashHandler.java:269)
	at org.eclipse.ui.splash.BasicSplashHandler$AbsolutePositionProgressMonitorPart.internalWorked(BasicSplashHandler.java:103)
	at org.eclipse.jface.wizard.ProgressMonitorPart.worked(ProgressMonitorPart.java:370)
	at org.eclipse.ui.internal.Workbench$StartupProgressBundleListener.bundleChanged(Workbench.java:333)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.dispatchEvent(BundleContextImpl.java:903)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.osgi.internal.framework.EquinoxEventPublisher.publishBundleEventPrivileged(EquinoxEventPublisher.java:213)
	at org.eclipse.osgi.internal.framework.EquinoxEventPublisher.publishBundleEvent(EquinoxEventPublisher.java:120)
	at org.eclipse.osgi.internal.framework.EquinoxEventPublisher.publishBundleEvent(EquinoxEventPublisher.java:112)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor.publishModuleEvent(EquinoxContainerAdaptor.java:156)
	at org.eclipse.osgi.container.Module.publishEvent(Module.java:476)
	at org.eclipse.osgi.container.Module.start(Module.java:467)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:470)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:529)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:325)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:423)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:372)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:364)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:161)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:564)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:174)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:905)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:55)
	at org.eclipse.mylyn.commons.core.ExtensionPointReader.readElement(ExtensionPointReader.java:189)
	at org.eclipse.mylyn.commons.core.ExtensionPointReader.read(ExtensionPointReader.java:151)
	at org.eclipse.mylyn.internal.commons.repositories.core.LocationService$LocationServiceInitializer.<clinit>(LocationService.java:40)
	at org.eclipse.mylyn.internal.commons.repositories.core.LocationService.getDefault(LocationService.java:63)
	at org.eclipse.mylyn.tasks.core.TaskRepository.<init>(TaskRepository.java:208)
	at org.eclipse.mylyn.tasks.core.TaskRepository.<init>(TaskRepository.java:232)
	at org.eclipse.mylyn.tasks.core.TaskRepository.<init>(TaskRepository.java:211)
	at org.eclipse.mylyn.internal.tasks.core.SaxRepositoriesContentHandler.handleRepositoryElement(SaxRepositoriesContentHandler.java:70)
	at org.eclipse.mylyn.internal.tasks.core.SaxRepositoriesContentHandler.startElement(SaxRepositoriesContentHandler.java:46)
	at org.apache.xerces.parsers.AbstractSAXParser.startElement(Unknown Source)
	at org.apache.xerces.impl.XMLNSDocumentScannerImpl.scanStartElement(Unknown Source)
	at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source)
	at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source)
	at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)
	at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)
	at org.apache.xerces.parsers.XMLParser.parse(Unknown Source)
	at org.apache.xerces.parsers.AbstractSAXParser.parse(Unknown Source)
	at org.eclipse.mylyn.internal.tasks.core.TaskRepositoriesExternalizer.readRepositoriesFromXML(TaskRepositoriesExternalizer.java:122)
	at org.eclipse.mylyn.internal.tasks.core.TaskRepositoryManager.loadRepositories(TaskRepositoryManager.java:338)
	at org.eclipse.mylyn.internal.tasks.core.TaskRepositoryManager.readRepositories(TaskRepositoryManager.java:314)
	at org.eclipse.mylyn.internal.tasks.core.RepositoryExternalizationParticipant.load(RepositoryExternalizationParticipant.java:69)
	at org.eclipse.mylyn.internal.tasks.core.externalization.AbstractExternalizationParticipant.performLoad(AbstractExternalizationParticipant.java:83)
	at org.eclipse.mylyn.internal.tasks.core.externalization.AbstractExternalizationParticipant.execute(AbstractExternalizationParticipant.java:73)
	at org.eclipse.mylyn.internal.tasks.core.externalization.ExternalizationManager$1.run(ExternalizationManager.java:117)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.mylyn.internal.tasks.core.externalization.ExternalizationManager.load(ExternalizationManager.java:106)
	at org.eclipse.mylyn.internal.tasks.core.externalization.ExternalizationManager.load(ExternalizationManager.java:84)
	at org.eclipse.mylyn.internal.tasks.ui.TasksUiPlugin.initializeDataSources(TasksUiPlugin.java:932)
	at org.eclipse.mylyn.internal.tasks.ui.TasksUiPlugin.start(TasksUiPlugin.java:620)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:774)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:724)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:932)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:309)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:470)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:529)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:325)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:423)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:372)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:364)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:161)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:564)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:174)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:905)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:55)
	at org.eclipse.core.internal.expressions.PropertyTesterDescriptor.instantiate(PropertyTesterDescriptor.java:96)
	at org.eclipse.core.internal.expressions.TypeExtension.findTypeExtender(TypeExtension.java:97)
	at org.eclipse.core.internal.expressions.TypeExtension.findTypeExtender(TypeExtension.java:130)
	at org.eclipse.core.internal.expressions.TypeExtension.findTypeExtender(TypeExtension.java:130)
	at org.eclipse.core.internal.expressions.TypeExtension.findTypeExtender(TypeExtension.java:130)
	at org.eclipse.core.internal.expressions.TypeExtensionManager.getProperty(TypeExtensionManager.java:119)
	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:97)
	at org.eclipse.e4.ui.internal.workbench.ContributionsAnalyzer.isVisible(ContributionsAnalyzer.java:257)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarContributionRecord.computeVisibility(ToolBarContributionRecord.java:127)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarContributionRecord.updateVisibility(ToolBarContributionRecord.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarManagerRenderer$5.changed(ToolBarManagerRenderer.java:479)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:114)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.runAndTrack(EclipseContext.java:324)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarManagerRenderer.processAddition(ToolBarManagerRenderer.java:471)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarManagerRenderer.generateContributions(ToolBarManagerRenderer.java:447)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarManagerRenderer.processContribution(ToolBarManagerRenderer.java:413)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolBarManagerRenderer.createWidget(ToolBarManagerRenderer.java:373)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:975)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:651)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeChildrenHandler(PartRenderingEngine.java:296)
	at sun.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:80)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:341)
	at org.eclipse.e4.ui.internal.workbench.ContributionsAnalyzer.processAddition(ContributionsAnalyzer.java:370)
	at org.eclipse.e4.ui.workbench.renderers.swt.TrimBarRenderer.addTrimContributions(TrimBarRenderer.java:171)
	at org.eclipse.e4.ui.workbench.renderers.swt.TrimBarRenderer.processContents(TrimBarRenderer.java:143)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeTopicToBeRendered(PartRenderingEngine.java:149)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:80)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:303)
	at org.eclipse.ui.internal.CoolBarToTrimManager.update(CoolBarToTrimManager.java:567)
	at org.eclipse.ui.internal.WorkbenchWindow.updateActionBars(WorkbenchWindow.java:2334)
	at org.eclipse.ui.internal.WorkbenchWindow.largeUpdateEnd(WorkbenchWindow.java:2387)
	at org.eclipse.ui.internal.Workbench.largeUpdateEnd(Workbench.java:3478)
	at org.eclipse.ui.internal.WorkbenchWindow.fillActionBars(WorkbenchWindow.java:2585)
	at org.eclipse.ui.internal.WorkbenchWindow.setup(WorkbenchWindow.java:667)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:966)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:151)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:118)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.inject(ContextInjectionFactory.java:73)
	at org.eclipse.ui.internal.Workbench.createWorkbenchWindow(Workbench.java:1525)
	at org.eclipse.ui.internal.Workbench.openWorkbenchWindow(Workbench.java:2653)
	at org.eclipse.ui.internal.Workbench.getWorkbenchPage(Workbench.java:2083)
	at org.eclipse.ui.internal.Workbench.setReference(Workbench.java:2131)
	at org.eclipse.ui.internal.Workbench.access$28(Workbench.java:2099)
	at org.eclipse.ui.internal.Workbench$35.handleEvent(Workbench.java:2021)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:5406)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.basic.impl.PartImpl.setContext(PartImpl.java:431)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:536)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:520)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:70)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:975)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:651)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1317)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:669)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:49)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:63)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:669)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:725)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1059)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:687)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)

!ENTRY org.eclipse.equinox.event 4 0 2016-12-12 14:52:15.341
!MESSAGE Exception while dispatching event org.osgi.service.event.Event [topic=org/eclipse/e4/ui/model/ui/UIElement/visible/SET] {ChangedElement=org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl@4f4c88f9 (elementId: org.eclipse.ui.ide.perspectivestack, tags: [Minimized], contributorURI: null) (widget: Composite {}, renderer: org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer@ffbfde5, toBeRendered: true, onTop: false, visible: false, containerData: 7500, accessibilityPhrase: null), org.eclipse.e4.data={ChangedElement=org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl@4f4c88f9 (elementId: org.eclipse.ui.ide.perspectivestack, tags: [Minimized], contributorURI: null) (widget: Composite {}, renderer: org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer@ffbfde5, toBeRendered: true, onTop: false, visible: false, containerData: 7500, accessibilityPhrase: null), AttName=visible, EventType=SET, OldValue=true, Widget=Composite {}, NewValue=false}, AttName=visible, EventType=SET, OldValue=true, Widget=Composite {}, NewValue=false} to handler org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler@12e8723a
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:65)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler$1.run(UIEventObjectSupplier.java:56)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:5406)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:53)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:345)
	at org.eclipse.e4.ui.workbench.addons.minmax.MinMaxAddon.minimize(MinMaxAddon.java:602)
	at org.eclipse.e4.ui.workbench.addons.minmax.MinMaxAddon.subscribeTopicTagsChanged(MinMaxAddon.java:361)
	at sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler$1.run(UIEventObjectSupplier.java:56)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:5406)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:53)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:304)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:303)
	at org.eclipse.e4.ui.workbench.addons.minmax.MinMaxAddon.maximize(MinMaxAddon.java:667)
	at org.eclipse.e4.ui.workbench.addons.minmax.MinMaxAddon.subscribeTopicTagsChanged(MinMaxAddon.java:363)
	at sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler$1.run(UIEventObjectSupplier.java:56)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:5406)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:53)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:304)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:303)
	at org.eclipse.ui.internal.WorkbenchIntroManager.setIntroStandby(WorkbenchIntroManager.java:196)
	at org.eclipse.ui.internal.WorkbenchIntroManager.showIntro(WorkbenchIntroManager.java:134)
	at org.eclipse.ui.application.WorkbenchWindowAdvisor.openIntro(WorkbenchWindowAdvisor.java:190)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.openIntro(IDEWorkbenchWindowAdvisor.java:567)
	at org.eclipse.ui.internal.WorkbenchWindow.setup(WorkbenchWindow.java:776)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:966)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:151)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:118)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.inject(ContextInjectionFactory.java:73)
	at org.eclipse.ui.internal.Workbench.createWorkbenchWindow(Workbench.java:1525)
	at org.eclipse.ui.internal.Workbench.openWorkbenchWindow(Workbench.java:2653)
	at org.eclipse.ui.internal.Workbench.getWorkbenchPage(Workbench.java:2083)
	at org.eclipse.ui.internal.Workbench.setReference(Workbench.java:2131)
	at org.eclipse.ui.internal.Workbench.access$28(Workbench.java:2099)
	at org.eclipse.ui.internal.Workbench$35.handleEvent(Workbench.java:2021)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:5406)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.basic.impl.PartImpl.setContext(PartImpl.java:431)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:536)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:520)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:70)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:975)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:651)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1317)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:669)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:49)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:63)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:669)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:725)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1059)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:687)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)
Caused by: org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4533)
	at org.eclipse.swt.SWT.error(SWT.java:4448)
	at org.eclipse.swt.SWT.error(SWT.java:4419)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:483)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:420)
	at org.eclipse.swt.widgets.Menu.getItems(Menu.java:526)
	at org.eclipse.swt.widgets.Menu.fixMenus(Menu.java:396)
	at org.eclipse.swt.widgets.Decorations.fixDecorations(Decorations.java:284)
	at org.eclipse.swt.widgets.Control.fixChildren(Control.java:2574)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:517)
	at org.eclipse.swt.widgets.Tree.fixChildren(Tree.java:1147)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Control.setParent(Control.java:4877)
	at org.eclipse.e4.ui.workbench.addons.cleanupaddon.CleanupAddon.subscribeVisibilityChanged(CleanupAddon.java:241)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	... 199 more

!ENTRY org.eclipse.equinox.event 4 0 2016-12-12 14:52:15.344
!MESSAGE Exception while dispatching event org.osgi.service.event.Event [topic=org/eclipse/e4/ui/model/ui/UIElement/visible/SET] {ChangedElement=org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl@4f4c88f9 (elementId: org.eclipse.ui.ide.perspectivestack, tags: [Minimized], contributorURI: null) (widget: Composite {}, renderer: org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer@ffbfde5, toBeRendered: true, onTop: false, visible: false, containerData: 7500, accessibilityPhrase: null), org.eclipse.e4.data={ChangedElement=org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl@4f4c88f9 (elementId: org.eclipse.ui.ide.perspectivestack, tags: [Minimized], contributorURI: null) (widget: Composite {}, renderer: org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer@ffbfde5, toBeRendered: true, onTop: false, visible: false, containerData: 7500, accessibilityPhrase: null), AttName=visible, EventType=SET, OldValue=true, Widget=Composite {}, NewValue=false}, AttName=visible, EventType=SET, OldValue=true, Widget=Composite {}, NewValue=false} to handler org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler@48c4b678
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:65)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:80)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:345)
	at org.eclipse.e4.ui.workbench.addons.minmax.MinMaxAddon.minimize(MinMaxAddon.java:602)
	at org.eclipse.e4.ui.workbench.addons.minmax.MinMaxAddon.subscribeTopicTagsChanged(MinMaxAddon.java:361)
	at sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler$1.run(UIEventObjectSupplier.java:56)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:5406)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:53)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:304)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:303)
	at org.eclipse.e4.ui.workbench.addons.minmax.MinMaxAddon.maximize(MinMaxAddon.java:667)
	at org.eclipse.e4.ui.workbench.addons.minmax.MinMaxAddon.subscribeTopicTagsChanged(MinMaxAddon.java:363)
	at sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler$1.run(UIEventObjectSupplier.java:56)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:5406)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:53)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:304)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:303)
	at org.eclipse.ui.internal.WorkbenchIntroManager.setIntroStandby(WorkbenchIntroManager.java:196)
	at org.eclipse.ui.internal.WorkbenchIntroManager.showIntro(WorkbenchIntroManager.java:134)
	at org.eclipse.ui.application.WorkbenchWindowAdvisor.openIntro(WorkbenchWindowAdvisor.java:190)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.openIntro(IDEWorkbenchWindowAdvisor.java:567)
	at org.eclipse.ui.internal.WorkbenchWindow.setup(WorkbenchWindow.java:776)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:966)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:151)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:118)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.inject(ContextInjectionFactory.java:73)
	at org.eclipse.ui.internal.Workbench.createWorkbenchWindow(Workbench.java:1525)
	at org.eclipse.ui.internal.Workbench.openWorkbenchWindow(Workbench.java:2653)
	at org.eclipse.ui.internal.Workbench.getWorkbenchPage(Workbench.java:2083)
	at org.eclipse.ui.internal.Workbench.setReference(Workbench.java:2131)
	at org.eclipse.ui.internal.Workbench.access$28(Workbench.java:2099)
	at org.eclipse.ui.internal.Workbench$35.handleEvent(Workbench.java:2021)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:5406)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.basic.impl.PartImpl.setContext(PartImpl.java:431)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:536)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:520)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:70)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:975)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:651)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1317)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:669)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:49)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:63)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:669)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:142)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:70)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:725)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:665)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:728)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:722)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:706)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1059)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:687)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)
Caused by: org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4533)
	at org.eclipse.swt.SWT.error(SWT.java:4448)
	at org.eclipse.swt.SWT.error(SWT.java:4419)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:483)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:420)
	at org.eclipse.swt.widgets.Menu.getItems(Menu.java:526)
	at org.eclipse.swt.widgets.Menu.fixMenus(Menu.java:396)
	at org.eclipse.swt.widgets.Decorations.fixDecorations(Decorations.java:284)
	at org.eclipse.swt.widgets.Control.fixChildren(Control.java:2574)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:517)
	at org.eclipse.swt.widgets.Tree.fixChildren(Tree.java:1147)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Control.setParent(Control.java:4877)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeVisibilityHandler(PartRenderingEngine.java:219)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	... 194 more

!ENTRY org.eclipse.equinox.event 4 0 2016-12-12 14:52:22.222
!MESSAGE Exception while dispatching event org.osgi.service.event.Event [topic=org/eclipse/e4/ui/model/ui/UIElement/visible/SET] {ChangedElement=org.eclipse.e4.ui.model.application.ui.basic.impl.PartSashContainerImpl@2806d6da (elementId: null, tags: [], contributorURI: null) (widget: Composite {}, renderer: org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer@64c48122, toBeRendered: true, onTop: false, visible: false, containerData: null, accessibilityPhrase: null) (horizontal: true), org.eclipse.e4.data={ChangedElement=org.eclipse.e4.ui.model.application.ui.basic.impl.PartSashContainerImpl@2806d6da (elementId: null, tags: [], contributorURI: null) (widget: Composite {}, renderer: org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer@64c48122, toBeRendered: true, onTop: false, visible: false, containerData: null, accessibilityPhrase: null) (horizontal: true), AttName=visible, EventType=SET, OldValue=true, Widget=Composite {}, NewValue=false}, AttName=visible, EventType=SET, OldValue=true, Widget=Composite {}, NewValue=false} to handler org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler@12e8723a
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:65)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler$1.run(UIEventObjectSupplier.java:56)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:5406)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:53)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:345)
	at org.eclipse.e4.ui.workbench.addons.cleanupaddon.CleanupAddon.subscribeRenderingChanged(CleanupAddon.java:344)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler$1.run(UIEventObjectSupplier.java:56)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:5406)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:53)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:303)
	at org.eclipse.e4.ui.workbench.addons.cleanupaddon.CleanupAddon$2.run(CleanupAddon.java:325)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4528)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4146)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:687)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)
Caused by: org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4533)
	at org.eclipse.swt.SWT.error(SWT.java:4448)
	at org.eclipse.swt.SWT.error(SWT.java:4419)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:483)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:420)
	at org.eclipse.swt.widgets.Menu.getItems(Menu.java:526)
	at org.eclipse.swt.widgets.Menu.fixMenus(Menu.java:396)
	at org.eclipse.swt.widgets.Decorations.fixDecorations(Decorations.java:284)
	at org.eclipse.swt.widgets.Control.fixChildren(Control.java:2574)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:517)
	at org.eclipse.swt.widgets.Tree.fixChildren(Tree.java:1147)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Control.setParent(Control.java:4877)
	at org.eclipse.e4.ui.workbench.addons.cleanupaddon.CleanupAddon.subscribeVisibilityChanged(CleanupAddon.java:241)
	at sun.reflect.GeneratedMethodAccessor33.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	... 69 more

!ENTRY org.eclipse.equinox.event 4 0 2016-12-12 14:52:22.224
!MESSAGE Exception while dispatching event org.osgi.service.event.Event [topic=org/eclipse/e4/ui/model/ui/UIElement/visible/SET] {ChangedElement=org.eclipse.e4.ui.model.application.ui.basic.impl.PartSashContainerImpl@2806d6da (elementId: null, tags: [], contributorURI: null) (widget: Composite {}, renderer: org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer@64c48122, toBeRendered: true, onTop: false, visible: false, containerData: null, accessibilityPhrase: null) (horizontal: true), org.eclipse.e4.data={ChangedElement=org.eclipse.e4.ui.model.application.ui.basic.impl.PartSashContainerImpl@2806d6da (elementId: null, tags: [], contributorURI: null) (widget: Composite {}, renderer: org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer@64c48122, toBeRendered: true, onTop: false, visible: false, containerData: null, accessibilityPhrase: null) (horizontal: true), AttName=visible, EventType=SET, OldValue=true, Widget=Composite {}, NewValue=false}, AttName=visible, EventType=SET, OldValue=true, Widget=Composite {}, NewValue=false} to handler org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler@48c4b678
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:65)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:80)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:345)
	at org.eclipse.e4.ui.workbench.addons.cleanupaddon.CleanupAddon.subscribeRenderingChanged(CleanupAddon.java:344)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler$1.run(UIEventObjectSupplier.java:56)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:5406)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:211)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:53)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:201)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:94)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:60)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:303)
	at org.eclipse.e4.ui.workbench.addons.cleanupaddon.CleanupAddon$2.run(CleanupAddon.java:325)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4528)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4146)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:687)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)
Caused by: org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4533)
	at org.eclipse.swt.SWT.error(SWT.java:4448)
	at org.eclipse.swt.SWT.error(SWT.java:4419)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:483)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:420)
	at org.eclipse.swt.widgets.Menu.getItems(Menu.java:526)
	at org.eclipse.swt.widgets.Menu.fixMenus(Menu.java:396)
	at org.eclipse.swt.widgets.Decorations.fixDecorations(Decorations.java:284)
	at org.eclipse.swt.widgets.Control.fixChildren(Control.java:2574)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:517)
	at org.eclipse.swt.widgets.Tree.fixChildren(Tree.java:1147)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Composite.fixChildren(Composite.java:520)
	at org.eclipse.swt.widgets.Control.setParent(Control.java:4877)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeVisibilityHandler(PartRenderingEngine.java:219)
	at sun.reflect.GeneratedMethodAccessor34.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	... 64 more

!ENTRY org.eclipse.jdt.ui 4 0 2016-12-12 14:54:14.577
!MESSAGE Invalid extension to quickFixProcessor. Must extends 'org.eclipse.jdt.ui.text.java.IQuickAssistProcessor'.org.eclipse.jdt.junit

!ENTRY org.eclipse.jdt.core 4 1005 2016-12-12 14:54:42.575
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 2 2016-12-12 14:54:42.578
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2016-12-12 14:54:42.580
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2016-12-12 14:54:42.581
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 0 2016-12-12 14:54:42.585
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2016-12-12 14:54:42.586
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.core 4 1005 2016-12-12 14:54:46.102
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 2 2016-12-12 14:54:46.103
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2016-12-12 14:54:46.103
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2016-12-12 14:54:46.103
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 0 2016-12-12 14:54:46.104
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2016-12-12 14:54:46.104
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subject
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.core 4 1005 2016-12-12 14:54:47.610
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 2 2016-12-12 14:54:47.611
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2016-12-12 14:54:47.612
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2016-12-12 14:54:47.612
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 0 2016-12-12 14:54:47.613
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2016-12-12 14:54:47.613
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.core 4 1005 2016-12-12 14:54:50.618
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 2 2016-12-12 14:54:50.618
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2016-12-12 14:54:50.619
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2016-12-12 14:54:50.619
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 0 2016-12-12 14:54:50.619
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2016-12-12 14:54:50.619
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

abstract aspect AbstractObserver<S, T> extends ObserverProtocol<Subject, Observer> {

	abstract pointcut subjectChange()
	
	@Override
	protected void updateObserver(Subject s, Observer o) {
		// TODO Auto-generated method stub
		
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11389)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11346)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:961)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 2 2016-12-12 15:24:19.426
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser.consumeMarkerAnnotation(AJSourceElementParser.java:507)
	at org.aspectj.org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:1081)
	at org.aspectj.org.eclipse.jdt.internal.compiler.parser.TheOriginalJDTParserClass.parse(TheOriginalJDTParserClass.java:9235)
	at org.aspectj.org.eclipse.jdt.internal.compiler.parser.TheOriginalJDTParserClass.parse(TheOriginalJDTParserClass.java:9483)
	at org.aspectj.org.eclipse.jdt.internal.compiler.parser.TheOriginalJDTParserClass.parse(TheOriginalJDTParserClass.java:9440)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser.parseCompilationUnit(AJSourceElementParser.java:1659)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.buildStructure(AJCompilationUnit.java:390)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.generateInfos(AJCompilationUnit.java:231)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.makeConsistent(AJCompilationUnit.java:446)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:219)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:112)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2016-12-12 15:24:19.427
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser.consumeMarkerAnnotation(AJSourceElementParser.java:507)
	at org.aspectj.org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:1081)
	at org.aspectj.org.eclipse.jdt.internal.compiler.parser.TheOriginalJDTParserClass.parse(TheOriginalJDTParserClass.java:9235)
	at org.aspectj.org.eclipse.jdt.internal.compiler.parser.TheOriginalJDTParserClass.parse(TheOriginalJDTParserClass.java:9483)
	at org.aspectj.org.eclipse.jdt.internal.compiler.parser.TheOriginalJDTParserClass.parse(TheOriginalJDTParserClass.java:9440)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser.parseCompilationUnit(AJSourceElementParser.java:1659)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.buildStructure(AJCompilationUnit.java:390)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.generateInfos(AJCompilationUnit.java:231)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.makeConsistent(AJCompilationUnit.java:446)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:219)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:112)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 1005 2016-12-12 16:19:36.279
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.SwingWrappers.WJFrame;

public aspect ColorObserver extends AbstractObserver<RainbowModel, WJFrame>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJFrame o) {
		// TODO Auto-generated method stub
		o.getContentPane().setBackground(s.getColor());
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.ihm;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class Rainbow {
    
    // ATTRIBUTS
    
    public static final int FRAMES_NB = 3;

    private static final int FRAME_WIDTH = 400;
    private static final int FRAME_HEIGHT = 300;
    private static final double[][] POS =
            new double[][] { {-1, -1}, {0, -1}, {-0.5, 0}};

    private JFrame[] frames;
    private JButton[] buttons;
    private JButton[] dingButtons;
    private JTextField[] colors;

    // CONSTRUCTEURS
    
    public Rainbow() {
        createViews();
        placeComponents();
        createControllers();
    }
    
    // REQUETES
    
    public JFrame getFrame(int i) {
        return frames[i];
    }
    
    public JButton getCmd(int i) {
        return buttons[i];
    }
    
    public JButton getDing(int i) {
        return dingButtons[i];
    }
    
    public JTextField getColor(int i) {
        return colors[i];
    }

    // COMMANDES
    
    public void display() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].pack();
            frames[i].setLocation(initLocation(i));
            frames[i].setVisible(true);
        }
    }

    // OUTILS
    
    private void createViews() {
        frames = new JFrame[FRAMES_NB];
        buttons = new JButton[FRAMES_NB];
        dingButtons = new JButton[FRAMES_NB];
        colors = new JTextField[FRAMES_NB];
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i] = new JFrame("Arc-en-ciel " + i);
            frames[i].setPreferredSize(
                    new Dimension(FRAME_WIDTH, FRAME_HEIGHT)
            );
            buttons[i] = new JButton("Modifier");
            dingButtons[i] = new JButton("Ding !");
            colors[i] = new JTextField("");
        }
    }
    
    private void placeComponents() {
        for (int i = 0; i < FRAMES_NB; i++) {
            JPanel p = new JPanel(); {
                p.add(buttons[i]);
                p.add(dingButtons[i]);
            }
            frames[i].add(p, BorderLayout.NORTH);
            p = new JPanel(new GridLayout(1, 0)); {
                p.add(colors[i]);
            }
            frames[i].add(p, BorderLayout.SOUTH);
        }
    }
    
    private void createControllers() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            dingButtons[i].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    Toolkit.getDefaultToolkit().beep();
                }
            });
        }
    }
    
    private Point initLocation(int i) {
        Dimension frameDim = frames[i].getPreferredSize();
        Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();
        Point p = new Point();
        p.x = (int) ((screenDim.width / 2.0) + (POS[i][0] * frameDim.width));
        p.y = (int) ((screenDim.height / 2.0) + (POS[i][1] * frameDim.height));
        return p;
    }
    
    // POINT D'ENTREE

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new Rainbow().display();
            }
        });
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Ce modle permet d'obtenir des couleurs.
 * On peut faire voluer le modle en lui commandant de changer de couleur,
 *  et consulter son tat  tout moment.
 * @inv <pre>
 *     getColor() != null </pre>
 */
public interface RainbowModel {
    
    // REQUETES
    
    /**
     * La couleur courante du modle.
     */
    Color getColor();

    // COMMANDES
    
    /**
     * Modification de l'tat interne.
     * Un appel  cette mthode oblige le modle a changer de couleur.
     * @post <pre>
     *     !getColor().equals(old getColor()) </pre>
     */
    void changeColor();
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

public abstract aspect AbstractObserver<S extends Subject, T extends Observer> extends ObserverProtocol<S, T> {

	public abstract pointcut subjectChange(S s); 
	
	after(S s) : subjectChange(s) {
		notifyObserversFor(s);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import java.awt.Color;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.Observer;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJTextField;

public aspect TextColorObserver extends AbstractObserver<RainbowModel, WJTextField>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJTextField o) {
		// TODO Auto-generated method stub
		Color c = s.getColor();
		o.setText("[" + c.getRed() + "," + c.getGreen()
        + "," + c.getBlue() + "]");
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Notre modle est une squence de couleurs (toutes distinctes) que l'on peut
 *  parcourir cycliquement.
 * Les valeurs de getColor() aprs chaque excution de changeColor() sont
 *  celles obtenues en parcourant cycliquement le tableau COLORS.
 */
public class StdRainbowModel implements RainbowModel {
    
    // ATTRIBUTS
    
    // La squence des diffrentes couleurs gres par le modle
    private static final Color[] COLORS = {
        Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY,
        Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
        Color.PINK, Color.RED, Color.WHITE, Color.YELLOW
    };

    // L'index courant dans le tableau des couleurs
    private int colorIndex;

    // CONSTRUCTEURS
    
    /**
     * Un modle standard, dont la couleur courante est la premire couleur
     *  du tableau.
     */
    public StdRainbowModel() {
        super();
        colorIndex = 0;
    }

    // REQUETES
    
    public Color getColor() {
        return COLORS[colorIndex];
    }

    // COMMANDES
    
    public void changeColor() {
        colorIndex = (colorIndex + 1) % COLORS.length;
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.awt.GraphicsConfiguration;
import java.awt.event.ActionEvent;

import javax.swing.Action;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

public aspect SwingWrappers {
    
    pointcut intoIHM() : within(fiche6.ihm..*);
    
    // fentres tissables
    
    pointcut frameCreation() : call(JFrame.new(..)) && intoIHM();
    
    JFrame around() : frameCreation() {
        JFrame f = proceed();
        return new WJFrame(f.getTitle(), f.getGraphicsConfiguration());
    }
    
    public static class WJFrame extends JFrame {
        public WJFrame(String t, GraphicsConfiguration gc) {
            super(t, gc);
        }
    }

    // champs tissables
    
    pointcut fieldCreation() : call(JTextField.new(..)) && intoIHM();
    
    JTextField around() : fieldCreation() {
        JTextField tf = proceed();
        WJTextField wjtf = new WJTextField();
        wjtf.setDocument(tf.getDocument());
        wjtf.setText(tf.getText());
        wjtf.setColumns(tf.getColumns());
        return wjtf;
    }
    
    public static class WJTextField extends JTextField {
        // rien
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.SwingWrappers.WJFrame;

public aspect ColorObserver extends AbstractObserver<RainbowModel, WJFrame>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJFrame o) {
		// TODO Auto-generated method stub
		o.getContentPane().setBackground(s.getColor());
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.ihm;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class Rainbow {
    
    // ATTRIBUTS
    
    public static final int FRAMES_NB = 3;

    private static final int FRAME_WIDTH = 400;
    private static final int FRAME_HEIGHT = 300;
    private static final double[][] POS =
            new double[][] { {-1, -1}, {0, -1}, {-0.5, 0}};

    private JFrame[] frames;
    private JButton[] buttons;
    private JButton[] dingButtons;
    private JTextField[] colors;

    // CONSTRUCTEURS
    
    public Rainbow() {
        createViews();
        placeComponents();
        createControllers();
    }
    
    // REQUETES
    
    public JFrame getFrame(int i) {
        return frames[i];
    }
    
    public JButton getCmd(int i) {
        return buttons[i];
    }
    
    public JButton getDing(int i) {
        return dingButtons[i];
    }
    
    public JTextField getColor(int i) {
        return colors[i];
    }

    // COMMANDES
    
    public void display() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].pack();
            frames[i].setLocation(initLocation(i));
            frames[i].setVisible(true);
        }
    }

    // OUTILS
    
    private void createViews() {
        frames = new JFrame[FRAMES_NB];
        buttons = new JButton[FRAMES_NB];
        dingButtons = new JButton[FRAMES_NB];
        colors = new JTextField[FRAMES_NB];
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i] = new JFrame("Arc-en-ciel " + i);
            frames[i].setPreferredSize(
                    new Dimension(FRAME_WIDTH, FRAME_HEIGHT)
            );
            buttons[i] = new JButton("Modifier");
            dingButtons[i] = new JButton("Ding !");
            colors[i] = new JTextField("");
        }
    }
    
    private void placeComponents() {
        for (int i = 0; i < FRAMES_NB; i++) {
            JPanel p = new JPanel(); {
                p.add(buttons[i]);
                p.add(dingButtons[i]);
            }
            frames[i].add(p, BorderLayout.NORTH);
            p = new JPanel(new GridLayout(1, 0)); {
                p.add(colors[i]);
            }
            frames[i].add(p, BorderLayout.SOUTH);
        }
    }
    
    private void createControllers() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            dingButtons[i].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    Toolkit.getDefaultToolkit().beep();
                }
            });
        }
    }
    
    private Point initLocation(int i) {
        Dimension frameDim = frames[i].getPreferredSize();
        Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();
        Point p = new Point();
        p.x = (int) ((screenDim.width / 2.0) + (POS[i][0] * frameDim.width));
        p.y = (int) ((screenDim.height / 2.0) + (POS[i][1] * frameDim.height));
        return p;
    }
    
    // POINT D'ENTREE

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new Rainbow().display();
            }
        });
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Ce modle permet d'obtenir des couleurs.
 * On peut faire voluer le modle en lui commandant de changer de couleur,
 *  et consulter son tat  tout moment.
 * @inv <pre>
 *     getColor() != null </pre>
 */
public interface RainbowModel {
    
    // REQUETES
    
    /**
     * La couleur courante du modle.
     */
    Color getColor();

    // COMMANDES
    
    /**
     * Modification de l'tat interne.
     * Un appel  cette mthode oblige le modle a changer de couleur.
     * @post <pre>
     *     !getColor().equals(old getColor()) </pre>
     */
    void changeColor();
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

public abstract aspect AbstractObserver<S extends Subject, T extends Observer> extends ObserverProtocol<S, T> {

	public abstract pointcut subjectChange(S s); 
	
	after(S s) : subjectChange(s) {
		notifyObserversFor(s);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import java.awt.Color;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.Observer;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJTextField;

public aspect TextColorObserver extends AbstractObserver<RainbowModel, WJTextField>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJTextField o) {
		// TODO Auto-generated method stub
		Color c = s.getColor();
		o.setText("[" + c.getRed() + "," + c.getGreen()
        + "," + c.getBlue() + "]");
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Notre modle est une squence de couleurs (toutes distinctes) que l'on peut
 *  parcourir cycliquement.
 * Les valeurs de getColor() aprs chaque excution de changeColor() sont
 *  celles obtenues en parcourant cycliquement le tableau COLORS.
 */
public class StdRainbowModel implements RainbowModel {
    
    // ATTRIBUTS
    
    // La squence des diffrentes couleurs gres par le modle
    private static final Color[] COLORS = {
        Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY,
        Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
        Color.PINK, Color.RED, Color.WHITE, Color.YELLOW
    };

    // L'index courant dans le tableau des couleurs
    private int colorIndex;

    // CONSTRUCTEURS
    
    /**
     * Un modle standard, dont la couleur courante est la premire couleur
     *  du tableau.
     */
    public StdRainbowModel() {
        super();
        colorIndex = 0;
    }

    // REQUETES
    
    public Color getColor() {
        return COLORS[colorIndex];
    }

    // COMMANDES
    
    public void changeColor() {
        colorIndex = (colorIndex + 1) % COLORS.length;
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.awt.GraphicsConfiguration;
import java.awt.event.ActionEvent;

import javax.swing.Action;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

public aspect SwingWrappers {
    
    pointcut intoIHM() : within(fiche6.ihm..*);
    
    // fentres tissables
    
    pointcut frameCreation() : call(JFrame.new(..)) && intoIHM();
    
    JFrame around() : frameCreation() {
        JFrame f = proceed();
        return new WJFrame(f.getTitle(), f.getGraphicsConfiguration());
    }
    
    public static class WJFrame extends JFrame {
        public WJFrame(String t, GraphicsConfiguration gc) {
            super(t, gc);
        }
    }

    // champs tissables
    
    pointcut fieldCreation() : call(JTextField.new(..)) && intoIHM();
    
    JTextField around() : fieldCreation() {
        JTextField tf = proceed();
        WJTextField wjtf = new WJTextField();
        wjtf.setDocument(tf.getDocument());
        wjtf.setText(tf.getText());
        wjtf.setColumns(tf.getColumns());
        return wjtf;
    }
    
    public static class WJTextField extends JTextField {
        // rien
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:11749)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12048)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12034)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:357)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12142)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11204)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11490)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:191)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:875)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10179)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 2 2016-12-12 16:19:36.279
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.SwingWrappers.WJFrame;

public aspect ColorObserver extends AbstractObserver<RainbowModel, WJFrame>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJFrame o) {
		// TODO Auto-generated method stub
		o.getContentPane().setBackground(s.getColor());
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.ihm;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class Rainbow {
    
    // ATTRIBUTS
    
    public static final int FRAMES_NB = 3;

    private static final int FRAME_WIDTH = 400;
    private static final int FRAME_HEIGHT = 300;
    private static final double[][] POS =
            new double[][] { {-1, -1}, {0, -1}, {-0.5, 0}};

    private JFrame[] frames;
    private JButton[] buttons;
    private JButton[] dingButtons;
    private JTextField[] colors;

    // CONSTRUCTEURS
    
    public Rainbow() {
        createViews();
        placeComponents();
        createControllers();
    }
    
    // REQUETES
    
    public JFrame getFrame(int i) {
        return frames[i];
    }
    
    public JButton getCmd(int i) {
        return buttons[i];
    }
    
    public JButton getDing(int i) {
        return dingButtons[i];
    }
    
    public JTextField getColor(int i) {
        return colors[i];
    }

    // COMMANDES
    
    public void display() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].pack();
            frames[i].setLocation(initLocation(i));
            frames[i].setVisible(true);
        }
    }

    // OUTILS
    
    private void createViews() {
        frames = new JFrame[FRAMES_NB];
        buttons = new JButton[FRAMES_NB];
        dingButtons = new JButton[FRAMES_NB];
        colors = new JTextField[FRAMES_NB];
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i] = new JFrame("Arc-en-ciel " + i);
            frames[i].setPreferredSize(
                    new Dimension(FRAME_WIDTH, FRAME_HEIGHT)
            );
            buttons[i] = new JButton("Modifier");
            dingButtons[i] = new JButton("Ding !");
            colors[i] = new JTextField("");
        }
    }
    
    private void placeComponents() {
        for (int i = 0; i < FRAMES_NB; i++) {
            JPanel p = new JPanel(); {
                p.add(buttons[i]);
                p.add(dingButtons[i]);
            }
            frames[i].add(p, BorderLayout.NORTH);
            p = new JPanel(new GridLayout(1, 0)); {
                p.add(colors[i]);
            }
            frames[i].add(p, BorderLayout.SOUTH);
        }
    }
    
    private void createControllers() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            dingButtons[i].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    Toolkit.getDefaultToolkit().beep();
                }
            });
        }
    }
    
    private Point initLocation(int i) {
        Dimension frameDim = frames[i].getPreferredSize();
        Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();
        Point p = new Point();
        p.x = (int) ((screenDim.width / 2.0) + (POS[i][0] * frameDim.width));
        p.y = (int) ((screenDim.height / 2.0) + (POS[i][1] * frameDim.height));
        return p;
    }
    
    // POINT D'ENTREE

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new Rainbow().display();
            }
        });
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Ce modle permet d'obtenir des couleurs.
 * On peut faire voluer le modle en lui commandant de changer de couleur,
 *  et consulter son tat  tout moment.
 * @inv <pre>
 *     getColor() != null </pre>
 */
public interface RainbowModel {
    
    // REQUETES
    
    /**
     * La couleur courante du modle.
     */
    Color getColor();

    // COMMANDES
    
    /**
     * Modification de l'tat interne.
     * Un appel  cette mthode oblige le modle a changer de couleur.
     * @post <pre>
     *     !getColor().equals(old getColor()) </pre>
     */
    void changeColor();
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

public abstract aspect AbstractObserver<S extends Subject, T extends Observer> extends ObserverProtocol<S, T> {

	public abstract pointcut subjectChange(S s); 
	
	after(S s) : subjectChange(s) {
		notifyObserversFor(s);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import java.awt.Color;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.Observer;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJTextField;

public aspect TextColorObserver extends AbstractObserver<RainbowModel, WJTextField>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJTextField o) {
		// TODO Auto-generated method stub
		Color c = s.getColor();
		o.setText("[" + c.getRed() + "," + c.getGreen()
        + "," + c.getBlue() + "]");
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Notre modle est une squence de couleurs (toutes distinctes) que l'on peut
 *  parcourir cycliquement.
 * Les valeurs de getColor() aprs chaque excution de changeColor() sont
 *  celles obtenues en parcourant cycliquement le tableau COLORS.
 */
public class StdRainbowModel implements RainbowModel {
    
    // ATTRIBUTS
    
    // La squence des diffrentes couleurs gres par le modle
    private static final Color[] COLORS = {
        Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY,
        Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
        Color.PINK, Color.RED, Color.WHITE, Color.YELLOW
    };

    // L'index courant dans le tableau des couleurs
    private int colorIndex;

    // CONSTRUCTEURS
    
    /**
     * Un modle standard, dont la couleur courante est la premire couleur
     *  du tableau.
     */
    public StdRainbowModel() {
        super();
        colorIndex = 0;
    }

    // REQUETES
    
    public Color getColor() {
        return COLORS[colorIndex];
    }

    // COMMANDES
    
    public void changeColor() {
        colorIndex = (colorIndex + 1) % COLORS.length;
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.awt.GraphicsConfiguration;
import java.awt.event.ActionEvent;

import javax.swing.Action;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

public aspect SwingWrappers {
    
    pointcut intoIHM() : within(fiche6.ihm..*);
    
    // fentres tissables
    
    pointcut frameCreation() : call(JFrame.new(..)) && intoIHM();
    
    JFrame around() : frameCreation() {
        JFrame f = proceed();
        return new WJFrame(f.getTitle(), f.getGraphicsConfiguration());
    }
    
    public static class WJFrame extends JFrame {
        public WJFrame(String t, GraphicsConfiguration gc) {
            super(t, gc);
        }
    }

    // champs tissables
    
    pointcut fieldCreation() : call(JTextField.new(..)) && intoIHM();
    
    JTextField around() : fieldCreation() {
        JTextField tf = proceed();
        WJTextField wjtf = new WJTextField();
        wjtf.setDocument(tf.getDocument());
        wjtf.setText(tf.getText());
        wjtf.setColumns(tf.getColumns());
        return wjtf;
    }
    
    public static class WJTextField extends JTextField {
        // rien
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.SwingWrappers.WJFrame;

public aspect ColorObserver extends AbstractObserver<RainbowModel, WJFrame>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJFrame o) {
		// TODO Auto-generated method stub
		o.getContentPane().setBackground(s.getColor());
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.ihm;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class Rainbow {
    
    // ATTRIBUTS
    
    public static final int FRAMES_NB = 3;

    private static final int FRAME_WIDTH = 400;
    private static final int FRAME_HEIGHT = 300;
    private static final double[][] POS =
            new double[][] { {-1, -1}, {0, -1}, {-0.5, 0}};

    private JFrame[] frames;
    private JButton[] buttons;
    private JButton[] dingButtons;
    private JTextField[] colors;

    // CONSTRUCTEURS
    
    public Rainbow() {
        createViews();
        placeComponents();
        createControllers();
    }
    
    // REQUETES
    
    public JFrame getFrame(int i) {
        return frames[i];
    }
    
    public JButton getCmd(int i) {
        return buttons[i];
    }
    
    public JButton getDing(int i) {
        return dingButtons[i];
    }
    
    public JTextField getColor(int i) {
        return colors[i];
    }

    // COMMANDES
    
    public void display() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].pack();
            frames[i].setLocation(initLocation(i));
            frames[i].setVisible(true);
        }
    }

    // OUTILS
    
    private void createViews() {
        frames = new JFrame[FRAMES_NB];
        buttons = new JButton[FRAMES_NB];
        dingButtons = new JButton[FRAMES_NB];
        colors = new JTextField[FRAMES_NB];
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i] = new JFrame("Arc-en-ciel " + i);
            frames[i].setPreferredSize(
                    new Dimension(FRAME_WIDTH, FRAME_HEIGHT)
            );
            buttons[i] = new JButton("Modifier");
            dingButtons[i] = new JButton("Ding !");
            colors[i] = new JTextField("");
        }
    }
    
    private void placeComponents() {
        for (int i = 0; i < FRAMES_NB; i++) {
            JPanel p = new JPanel(); {
                p.add(buttons[i]);
                p.add(dingButtons[i]);
            }
            frames[i].add(p, BorderLayout.NORTH);
            p = new JPanel(new GridLayout(1, 0)); {
                p.add(colors[i]);
            }
            frames[i].add(p, BorderLayout.SOUTH);
        }
    }
    
    private void createControllers() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            dingButtons[i].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    Toolkit.getDefaultToolkit().beep();
                }
            });
        }
    }
    
    private Point initLocation(int i) {
        Dimension frameDim = frames[i].getPreferredSize();
        Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();
        Point p = new Point();
        p.x = (int) ((screenDim.width / 2.0) + (POS[i][0] * frameDim.width));
        p.y = (int) ((screenDim.height / 2.0) + (POS[i][1] * frameDim.height));
        return p;
    }
    
    // POINT D'ENTREE

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new Rainbow().display();
            }
        });
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Ce modle permet d'obtenir des couleurs.
 * On peut faire voluer le modle en lui commandant de changer de couleur,
 *  et consulter son tat  tout moment.
 * @inv <pre>
 *     getColor() != null </pre>
 */
public interface RainbowModel {
    
    // REQUETES
    
    /**
     * La couleur courante du modle.
     */
    Color getColor();

    // COMMANDES
    
    /**
     * Modification de l'tat interne.
     * Un appel  cette mthode oblige le modle a changer de couleur.
     * @post <pre>
     *     !getColor().equals(old getColor()) </pre>
     */
    void changeColor();
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

public abstract aspect AbstractObserver<S extends Subject, T extends Observer> extends ObserverProtocol<S, T> {

	public abstract pointcut subjectChange(S s); 
	
	after(S s) : subjectChange(s) {
		notifyObserversFor(s);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import java.awt.Color;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.Observer;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJTextField;

public aspect TextColorObserver extends AbstractObserver<RainbowModel, WJTextField>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJTextField o) {
		// TODO Auto-generated method stub
		Color c = s.getColor();
		o.setText("[" + c.getRed() + "," + c.getGreen()
        + "," + c.getBlue() + "]");
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Notre modle est une squence de couleurs (toutes distinctes) que l'on peut
 *  parcourir cycliquement.
 * Les valeurs de getColor() aprs chaque excution de changeColor() sont
 *  celles obtenues en parcourant cycliquement le tableau COLORS.
 */
public class StdRainbowModel implements RainbowModel {
    
    // ATTRIBUTS
    
    // La squence des diffrentes couleurs gres par le modle
    private static final Color[] COLORS = {
        Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY,
        Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
        Color.PINK, Color.RED, Color.WHITE, Color.YELLOW
    };

    // L'index courant dans le tableau des couleurs
    private int colorIndex;

    // CONSTRUCTEURS
    
    /**
     * Un modle standard, dont la couleur courante est la premire couleur
     *  du tableau.
     */
    public StdRainbowModel() {
        super();
        colorIndex = 0;
    }

    // REQUETES
    
    public Color getColor() {
        return COLORS[colorIndex];
    }

    // COMMANDES
    
    public void changeColor() {
        colorIndex = (colorIndex + 1) % COLORS.length;
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.awt.GraphicsConfiguration;
import java.awt.event.ActionEvent;

import javax.swing.Action;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

public aspect SwingWrappers {
    
    pointcut intoIHM() : within(fiche6.ihm..*);
    
    // fentres tissables
    
    pointcut frameCreation() : call(JFrame.new(..)) && intoIHM();
    
    JFrame around() : frameCreation() {
        JFrame f = proceed();
        return new WJFrame(f.getTitle(), f.getGraphicsConfiguration());
    }
    
    public static class WJFrame extends JFrame {
        public WJFrame(String t, GraphicsConfiguration gc) {
            super(t, gc);
        }
    }

    // champs tissables
    
    pointcut fieldCreation() : call(JTextField.new(..)) && intoIHM();
    
    JTextField around() : fieldCreation() {
        JTextField tf = proceed();
        WJTextField wjtf = new WJTextField();
        wjtf.setDocument(tf.getDocument());
        wjtf.setText(tf.getText());
        wjtf.setColumns(tf.getColumns());
        return wjtf;
    }
    
    public static class WJTextField extends JTextField {
        // rien
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:11749)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12048)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12034)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:357)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12142)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11204)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11490)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:191)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:875)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10179)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.SwingWrappers.WJFrame;

public aspect ColorObserver extends AbstractObserver<RainbowModel, WJFrame>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJFrame o) {
		// TODO Auto-generated method stub
		o.getContentPane().setBackground(s.getColor());
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.ihm;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class Rainbow {
    
    // ATTRIBUTS
    
    public static final int FRAMES_NB = 3;

    private static final int FRAME_WIDTH = 400;
    private static final int FRAME_HEIGHT = 300;
    private static final double[][] POS =
            new double[][] { {-1, -1}, {0, -1}, {-0.5, 0}};

    private JFrame[] frames;
    private JButton[] buttons;
    private JButton[] dingButtons;
    private JTextField[] colors;

    // CONSTRUCTEURS
    
    public Rainbow() {
        createViews();
        placeComponents();
        createControllers();
    }
    
    // REQUETES
    
    public JFrame getFrame(int i) {
        return frames[i];
    }
    
    public JButton getCmd(int i) {
        return buttons[i];
    }
    
    public JButton getDing(int i) {
        return dingButtons[i];
    }
    
    public JTextField getColor(int i) {
        return colors[i];
    }

    // COMMANDES
    
    public void display() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].pack();
            frames[i].setLocation(initLocation(i));
            frames[i].setVisible(true);
        }
    }

    // OUTILS
    
    private void createViews() {
        frames = new JFrame[FRAMES_NB];
        buttons = new JButton[FRAMES_NB];
        dingButtons = new JButton[FRAMES_NB];
        colors = new JTextField[FRAMES_NB];
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i] = new JFrame("Arc-en-ciel " + i);
            frames[i].setPreferredSize(
                    new Dimension(FRAME_WIDTH, FRAME_HEIGHT)
            );
            buttons[i] = new JButton("Modifier");
            dingButtons[i] = new JButton("Ding !");
            colors[i] = new JTextField("");
        }
    }
    
    private void placeComponents() {
        for (int i = 0; i < FRAMES_NB; i++) {
            JPanel p = new JPanel(); {
                p.add(buttons[i]);
                p.add(dingButtons[i]);
            }
            frames[i].add(p, BorderLayout.NORTH);
            p = new JPanel(new GridLayout(1, 0)); {
                p.add(colors[i]);
            }
            frames[i].add(p, BorderLayout.SOUTH);
        }
    }
    
    private void createControllers() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            dingButtons[i].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    Toolkit.getDefaultToolkit().beep();
                }
            });
        }
    }
    
    private Point initLocation(int i) {
        Dimension frameDim = frames[i].getPreferredSize();
        Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();
        Point p = new Point();
        p.x = (int) ((screenDim.width / 2.0) + (POS[i][0] * frameDim.width));
        p.y = (int) ((screenDim.height / 2.0) + (POS[i][1] * frameDim.height));
        return p;
    }
    
    // POINT D'ENTREE

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new Rainbow().display();
            }
        });
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Ce modle permet d'obtenir des couleurs.
 * On peut faire voluer le modle en lui commandant de changer de couleur,
 *  et consulter son tat  tout moment.
 * @inv <pre>
 *     getColor() != null </pre>
 */
public interface RainbowModel {
    
    // REQUETES
    
    /**
     * La couleur courante du modle.
     */
    Color getColor();

    // COMMANDES
    
    /**
     * Modification de l'tat interne.
     * Un appel  cette mthode oblige le modle a changer de couleur.
     * @post <pre>
     *     !getColor().equals(old getColor()) </pre>
     */
    void changeColor();
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

public abstract aspect AbstractObserver<S extends Subject, T extends Observer> extends ObserverProtocol<S, T> {

	public abstract pointcut subjectChange(S s); 
	
	after(S s) : subjectChange(s) {
		notifyObserversFor(s);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import java.awt.Color;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.Observer;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJTextField;

public aspect TextColorObserver extends AbstractObserver<RainbowModel, WJTextField>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJTextField o) {
		// TODO Auto-generated method stub
		Color c = s.getColor();
		o.setText("[" + c.getRed() + "," + c.getGreen()
        + "," + c.getBlue() + "]");
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Notre modle est une squence de couleurs (toutes distinctes) que l'on peut
 *  parcourir cycliquement.
 * Les valeurs de getColor() aprs chaque excution de changeColor() sont
 *  celles obtenues en parcourant cycliquement le tableau COLORS.
 */
public class StdRainbowModel implements RainbowModel {
    
    // ATTRIBUTS
    
    // La squence des diffrentes couleurs gres par le modle
    private static final Color[] COLORS = {
        Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY,
        Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
        Color.PINK, Color.RED, Color.WHITE, Color.YELLOW
    };

    // L'index courant dans le tableau des couleurs
    private int colorIndex;

    // CONSTRUCTEURS
    
    /**
     * Un modle standard, dont la couleur courante est la premire couleur
     *  du tableau.
     */
    public StdRainbowModel() {
        super();
        colorIndex = 0;
    }

    // REQUETES
    
    public Color getColor() {
        return COLORS[colorIndex];
    }

    // COMMANDES
    
    public void changeColor() {
        colorIndex = (colorIndex + 1) % COLORS.length;
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.awt.GraphicsConfiguration;
import java.awt.event.ActionEvent;

import javax.swing.Action;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

public aspect SwingWrappers {
    
    pointcut intoIHM() : within(fiche6.ihm..*);
    
    // fentres tissables
    
    pointcut frameCreation() : call(JFrame.new(..)) && intoIHM();
    
    JFrame around() : frameCreation() {
        JFrame f = proceed();
        return new WJFrame(f.getTitle(), f.getGraphicsConfiguration());
    }
    
    public static class WJFrame extends JFrame {
        public WJFrame(String t, GraphicsConfiguration gc) {
            super(t, gc);
        }
    }

    // champs tissables
    
    pointcut fieldCreation() : call(JTextField.new(..)) && intoIHM();
    
    JTextField around() : fieldCreation() {
        JTextField tf = proceed();
        WJTextField wjtf = new WJTextField();
        wjtf.setDocument(tf.getDocument());
        wjtf.setText(tf.getText());
        wjtf.setColumns(tf.getColumns());
        return wjtf;
    }
    
    public static class WJTextField extends JTextField {
        // rien
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:11749)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12048)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12034)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:357)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12142)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11204)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11490)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:191)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:875)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10179)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2016-12-12 16:19:36.280
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.SwingWrappers.WJFrame;

public aspect ColorObserver extends AbstractObserver<RainbowModel, WJFrame>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJFrame o) {
		// TODO Auto-generated method stub
		o.getContentPane().setBackground(s.getColor());
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.ihm;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class Rainbow {
    
    // ATTRIBUTS
    
    public static final int FRAMES_NB = 3;

    private static final int FRAME_WIDTH = 400;
    private static final int FRAME_HEIGHT = 300;
    private static final double[][] POS =
            new double[][] { {-1, -1}, {0, -1}, {-0.5, 0}};

    private JFrame[] frames;
    private JButton[] buttons;
    private JButton[] dingButtons;
    private JTextField[] colors;

    // CONSTRUCTEURS
    
    public Rainbow() {
        createViews();
        placeComponents();
        createControllers();
    }
    
    // REQUETES
    
    public JFrame getFrame(int i) {
        return frames[i];
    }
    
    public JButton getCmd(int i) {
        return buttons[i];
    }
    
    public JButton getDing(int i) {
        return dingButtons[i];
    }
    
    public JTextField getColor(int i) {
        return colors[i];
    }

    // COMMANDES
    
    public void display() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].pack();
            frames[i].setLocation(initLocation(i));
            frames[i].setVisible(true);
        }
    }

    // OUTILS
    
    private void createViews() {
        frames = new JFrame[FRAMES_NB];
        buttons = new JButton[FRAMES_NB];
        dingButtons = new JButton[FRAMES_NB];
        colors = new JTextField[FRAMES_NB];
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i] = new JFrame("Arc-en-ciel " + i);
            frames[i].setPreferredSize(
                    new Dimension(FRAME_WIDTH, FRAME_HEIGHT)
            );
            buttons[i] = new JButton("Modifier");
            dingButtons[i] = new JButton("Ding !");
            colors[i] = new JTextField("");
        }
    }
    
    private void placeComponents() {
        for (int i = 0; i < FRAMES_NB; i++) {
            JPanel p = new JPanel(); {
                p.add(buttons[i]);
                p.add(dingButtons[i]);
            }
            frames[i].add(p, BorderLayout.NORTH);
            p = new JPanel(new GridLayout(1, 0)); {
                p.add(colors[i]);
            }
            frames[i].add(p, BorderLayout.SOUTH);
        }
    }
    
    private void createControllers() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            dingButtons[i].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    Toolkit.getDefaultToolkit().beep();
                }
            });
        }
    }
    
    private Point initLocation(int i) {
        Dimension frameDim = frames[i].getPreferredSize();
        Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();
        Point p = new Point();
        p.x = (int) ((screenDim.width / 2.0) + (POS[i][0] * frameDim.width));
        p.y = (int) ((screenDim.height / 2.0) + (POS[i][1] * frameDim.height));
        return p;
    }
    
    // POINT D'ENTREE

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new Rainbow().display();
            }
        });
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Ce modle permet d'obtenir des couleurs.
 * On peut faire voluer le modle en lui commandant de changer de couleur,
 *  et consulter son tat  tout moment.
 * @inv <pre>
 *     getColor() != null </pre>
 */
public interface RainbowModel {
    
    // REQUETES
    
    /**
     * La couleur courante du modle.
     */
    Color getColor();

    // COMMANDES
    
    /**
     * Modification de l'tat interne.
     * Un appel  cette mthode oblige le modle a changer de couleur.
     * @post <pre>
     *     !getColor().equals(old getColor()) </pre>
     */
    void changeColor();
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

public abstract aspect AbstractObserver<S extends Subject, T extends Observer> extends ObserverProtocol<S, T> {

	public abstract pointcut subjectChange(S s); 
	
	after(S s) : subjectChange(s) {
		notifyObserversFor(s);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import java.awt.Color;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.Observer;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJTextField;

public aspect TextColorObserver extends AbstractObserver<RainbowModel, WJTextField>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJTextField o) {
		// TODO Auto-generated method stub
		Color c = s.getColor();
		o.setText("[" + c.getRed() + "," + c.getGreen()
        + "," + c.getBlue() + "]");
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Notre modle est une squence de couleurs (toutes distinctes) que l'on peut
 *  parcourir cycliquement.
 * Les valeurs de getColor() aprs chaque excution de changeColor() sont
 *  celles obtenues en parcourant cycliquement le tableau COLORS.
 */
public class StdRainbowModel implements RainbowModel {
    
    // ATTRIBUTS
    
    // La squence des diffrentes couleurs gres par le modle
    private static final Color[] COLORS = {
        Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY,
        Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
        Color.PINK, Color.RED, Color.WHITE, Color.YELLOW
    };

    // L'index courant dans le tableau des couleurs
    private int colorIndex;

    // CONSTRUCTEURS
    
    /**
     * Un modle standard, dont la couleur courante est la premire couleur
     *  du tableau.
     */
    public StdRainbowModel() {
        super();
        colorIndex = 0;
    }

    // REQUETES
    
    public Color getColor() {
        return COLORS[colorIndex];
    }

    // COMMANDES
    
    public void changeColor() {
        colorIndex = (colorIndex + 1) % COLORS.length;
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.awt.GraphicsConfiguration;
import java.awt.event.ActionEvent;

import javax.swing.Action;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

public aspect SwingWrappers {
    
    pointcut intoIHM() : within(fiche6.ihm..*);
    
    // fentres tissables
    
    pointcut frameCreation() : call(JFrame.new(..)) && intoIHM();
    
    JFrame around() : frameCreation() {
        JFrame f = proceed();
        return new WJFrame(f.getTitle(), f.getGraphicsConfiguration());
    }
    
    public static class WJFrame extends JFrame {
        public WJFrame(String t, GraphicsConfiguration gc) {
            super(t, gc);
        }
    }

    // champs tissables
    
    pointcut fieldCreation() : call(JTextField.new(..)) && intoIHM();
    
    JTextField around() : fieldCreation() {
        JTextField tf = proceed();
        WJTextField wjtf = new WJTextField();
        wjtf.setDocument(tf.getDocument());
        wjtf.setText(tf.getText());
        wjtf.setColumns(tf.getColumns());
        return wjtf;
    }
    
    public static class WJTextField extends JTextField {
        // rien
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.SwingWrappers.WJFrame;

public aspect ColorObserver extends AbstractObserver<RainbowModel, WJFrame>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJFrame o) {
		// TODO Auto-generated method stub
		o.getContentPane().setBackground(s.getColor());
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.ihm;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class Rainbow {
    
    // ATTRIBUTS
    
    public static final int FRAMES_NB = 3;

    private static final int FRAME_WIDTH = 400;
    private static final int FRAME_HEIGHT = 300;
    private static final double[][] POS =
            new double[][] { {-1, -1}, {0, -1}, {-0.5, 0}};

    private JFrame[] frames;
    private JButton[] buttons;
    private JButton[] dingButtons;
    private JTextField[] colors;

    // CONSTRUCTEURS
    
    public Rainbow() {
        createViews();
        placeComponents();
        createControllers();
    }
    
    // REQUETES
    
    public JFrame getFrame(int i) {
        return frames[i];
    }
    
    public JButton getCmd(int i) {
        return buttons[i];
    }
    
    public JButton getDing(int i) {
        return dingButtons[i];
    }
    
    public JTextField getColor(int i) {
        return colors[i];
    }

    // COMMANDES
    
    public void display() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].pack();
            frames[i].setLocation(initLocation(i));
            frames[i].setVisible(true);
        }
    }

    // OUTILS
    
    private void createViews() {
        frames = new JFrame[FRAMES_NB];
        buttons = new JButton[FRAMES_NB];
        dingButtons = new JButton[FRAMES_NB];
        colors = new JTextField[FRAMES_NB];
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i] = new JFrame("Arc-en-ciel " + i);
            frames[i].setPreferredSize(
                    new Dimension(FRAME_WIDTH, FRAME_HEIGHT)
            );
            buttons[i] = new JButton("Modifier");
            dingButtons[i] = new JButton("Ding !");
            colors[i] = new JTextField("");
        }
    }
    
    private void placeComponents() {
        for (int i = 0; i < FRAMES_NB; i++) {
            JPanel p = new JPanel(); {
                p.add(buttons[i]);
                p.add(dingButtons[i]);
            }
            frames[i].add(p, BorderLayout.NORTH);
            p = new JPanel(new GridLayout(1, 0)); {
                p.add(colors[i]);
            }
            frames[i].add(p, BorderLayout.SOUTH);
        }
    }
    
    private void createControllers() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            dingButtons[i].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    Toolkit.getDefaultToolkit().beep();
                }
            });
        }
    }
    
    private Point initLocation(int i) {
        Dimension frameDim = frames[i].getPreferredSize();
        Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();
        Point p = new Point();
        p.x = (int) ((screenDim.width / 2.0) + (POS[i][0] * frameDim.width));
        p.y = (int) ((screenDim.height / 2.0) + (POS[i][1] * frameDim.height));
        return p;
    }
    
    // POINT D'ENTREE

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new Rainbow().display();
            }
        });
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Ce modle permet d'obtenir des couleurs.
 * On peut faire voluer le modle en lui commandant de changer de couleur,
 *  et consulter son tat  tout moment.
 * @inv <pre>
 *     getColor() != null </pre>
 */
public interface RainbowModel {
    
    // REQUETES
    
    /**
     * La couleur courante du modle.
     */
    Color getColor();

    // COMMANDES
    
    /**
     * Modification de l'tat interne.
     * Un appel  cette mthode oblige le modle a changer de couleur.
     * @post <pre>
     *     !getColor().equals(old getColor()) </pre>
     */
    void changeColor();
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

public abstract aspect AbstractObserver<S extends Subject, T extends Observer> extends ObserverProtocol<S, T> {

	public abstract pointcut subjectChange(S s); 
	
	after(S s) : subjectChange(s) {
		notifyObserversFor(s);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import java.awt.Color;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.Observer;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJTextField;

public aspect TextColorObserver extends AbstractObserver<RainbowModel, WJTextField>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJTextField o) {
		// TODO Auto-generated method stub
		Color c = s.getColor();
		o.setText("[" + c.getRed() + "," + c.getGreen()
        + "," + c.getBlue() + "]");
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Notre modle est une squence de couleurs (toutes distinctes) que l'on peut
 *  parcourir cycliquement.
 * Les valeurs de getColor() aprs chaque excution de changeColor() sont
 *  celles obtenues en parcourant cycliquement le tableau COLORS.
 */
public class StdRainbowModel implements RainbowModel {
    
    // ATTRIBUTS
    
    // La squence des diffrentes couleurs gres par le modle
    private static final Color[] COLORS = {
        Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY,
        Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
        Color.PINK, Color.RED, Color.WHITE, Color.YELLOW
    };

    // L'index courant dans le tableau des couleurs
    private int colorIndex;

    // CONSTRUCTEURS
    
    /**
     * Un modle standard, dont la couleur courante est la premire couleur
     *  du tableau.
     */
    public StdRainbowModel() {
        super();
        colorIndex = 0;
    }

    // REQUETES
    
    public Color getColor() {
        return COLORS[colorIndex];
    }

    // COMMANDES
    
    public void changeColor() {
        colorIndex = (colorIndex + 1) % COLORS.length;
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.awt.GraphicsConfiguration;
import java.awt.event.ActionEvent;

import javax.swing.Action;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

public aspect SwingWrappers {
    
    pointcut intoIHM() : within(fiche6.ihm..*);
    
    // fentres tissables
    
    pointcut frameCreation() : call(JFrame.new(..)) && intoIHM();
    
    JFrame around() : frameCreation() {
        JFrame f = proceed();
        return new WJFrame(f.getTitle(), f.getGraphicsConfiguration());
    }
    
    public static class WJFrame extends JFrame {
        public WJFrame(String t, GraphicsConfiguration gc) {
            super(t, gc);
        }
    }

    // champs tissables
    
    pointcut fieldCreation() : call(JTextField.new(..)) && intoIHM();
    
    JTextField around() : fieldCreation() {
        JTextField tf = proceed();
        WJTextField wjtf = new WJTextField();
        wjtf.setDocument(tf.getDocument());
        wjtf.setText(tf.getText());
        wjtf.setColumns(tf.getColumns());
        return wjtf;
    }
    
    public static class WJTextField extends JTextField {
        // rien
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:11749)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12048)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12034)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:357)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12142)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11204)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11490)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:191)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:875)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10179)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2016-12-12 16:19:36.280
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.SwingWrappers.WJFrame;

public aspect ColorObserver extends AbstractObserver<RainbowModel, WJFrame>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJFrame o) {
		// TODO Auto-generated method stub
		o.getContentPane().setBackground(s.getColor());
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.ihm;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class Rainbow {
    
    // ATTRIBUTS
    
    public static final int FRAMES_NB = 3;

    private static final int FRAME_WIDTH = 400;
    private static final int FRAME_HEIGHT = 300;
    private static final double[][] POS =
            new double[][] { {-1, -1}, {0, -1}, {-0.5, 0}};

    private JFrame[] frames;
    private JButton[] buttons;
    private JButton[] dingButtons;
    private JTextField[] colors;

    // CONSTRUCTEURS
    
    public Rainbow() {
        createViews();
        placeComponents();
        createControllers();
    }
    
    // REQUETES
    
    public JFrame getFrame(int i) {
        return frames[i];
    }
    
    public JButton getCmd(int i) {
        return buttons[i];
    }
    
    public JButton getDing(int i) {
        return dingButtons[i];
    }
    
    public JTextField getColor(int i) {
        return colors[i];
    }

    // COMMANDES
    
    public void display() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].pack();
            frames[i].setLocation(initLocation(i));
            frames[i].setVisible(true);
        }
    }

    // OUTILS
    
    private void createViews() {
        frames = new JFrame[FRAMES_NB];
        buttons = new JButton[FRAMES_NB];
        dingButtons = new JButton[FRAMES_NB];
        colors = new JTextField[FRAMES_NB];
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i] = new JFrame("Arc-en-ciel " + i);
            frames[i].setPreferredSize(
                    new Dimension(FRAME_WIDTH, FRAME_HEIGHT)
            );
            buttons[i] = new JButton("Modifier");
            dingButtons[i] = new JButton("Ding !");
            colors[i] = new JTextField("");
        }
    }
    
    private void placeComponents() {
        for (int i = 0; i < FRAMES_NB; i++) {
            JPanel p = new JPanel(); {
                p.add(buttons[i]);
                p.add(dingButtons[i]);
            }
            frames[i].add(p, BorderLayout.NORTH);
            p = new JPanel(new GridLayout(1, 0)); {
                p.add(colors[i]);
            }
            frames[i].add(p, BorderLayout.SOUTH);
        }
    }
    
    private void createControllers() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            dingButtons[i].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    Toolkit.getDefaultToolkit().beep();
                }
            });
        }
    }
    
    private Point initLocation(int i) {
        Dimension frameDim = frames[i].getPreferredSize();
        Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();
        Point p = new Point();
        p.x = (int) ((screenDim.width / 2.0) + (POS[i][0] * frameDim.width));
        p.y = (int) ((screenDim.height / 2.0) + (POS[i][1] * frameDim.height));
        return p;
    }
    
    // POINT D'ENTREE

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new Rainbow().display();
            }
        });
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Ce modle permet d'obtenir des couleurs.
 * On peut faire voluer le modle en lui commandant de changer de couleur,
 *  et consulter son tat  tout moment.
 * @inv <pre>
 *     getColor() != null </pre>
 */
public interface RainbowModel {
    
    // REQUETES
    
    /**
     * La couleur courante du modle.
     */
    Color getColor();

    // COMMANDES
    
    /**
     * Modification de l'tat interne.
     * Un appel  cette mthode oblige le modle a changer de couleur.
     * @post <pre>
     *     !getColor().equals(old getColor()) </pre>
     */
    void changeColor();
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

public abstract aspect AbstractObserver<S extends Subject, T extends Observer> extends ObserverProtocol<S, T> {

	public abstract pointcut subjectChange(S s); 
	
	after(S s) : subjectChange(s) {
		notifyObserversFor(s);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import java.awt.Color;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.Observer;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJTextField;

public aspect TextColorObserver extends AbstractObserver<RainbowModel, WJTextField>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJTextField o) {
		// TODO Auto-generated method stub
		Color c = s.getColor();
		o.setText("[" + c.getRed() + "," + c.getGreen()
        + "," + c.getBlue() + "]");
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Notre modle est une squence de couleurs (toutes distinctes) que l'on peut
 *  parcourir cycliquement.
 * Les valeurs de getColor() aprs chaque excution de changeColor() sont
 *  celles obtenues en parcourant cycliquement le tableau COLORS.
 */
public class StdRainbowModel implements RainbowModel {
    
    // ATTRIBUTS
    
    // La squence des diffrentes couleurs gres par le modle
    private static final Color[] COLORS = {
        Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY,
        Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
        Color.PINK, Color.RED, Color.WHITE, Color.YELLOW
    };

    // L'index courant dans le tableau des couleurs
    private int colorIndex;

    // CONSTRUCTEURS
    
    /**
     * Un modle standard, dont la couleur courante est la premire couleur
     *  du tableau.
     */
    public StdRainbowModel() {
        super();
        colorIndex = 0;
    }

    // REQUETES
    
    public Color getColor() {
        return COLORS[colorIndex];
    }

    // COMMANDES
    
    public void changeColor() {
        colorIndex = (colorIndex + 1) % COLORS.length;
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.awt.GraphicsConfiguration;
import java.awt.event.ActionEvent;

import javax.swing.Action;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

public aspect SwingWrappers {
    
    pointcut intoIHM() : within(fiche6.ihm..*);
    
    // fentres tissables
    
    pointcut frameCreation() : call(JFrame.new(..)) && intoIHM();
    
    JFrame around() : frameCreation() {
        JFrame f = proceed();
        return new WJFrame(f.getTitle(), f.getGraphicsConfiguration());
    }
    
    public static class WJFrame extends JFrame {
        public WJFrame(String t, GraphicsConfiguration gc) {
            super(t, gc);
        }
    }

    // champs tissables
    
    pointcut fieldCreation() : call(JTextField.new(..)) && intoIHM();
    
    JTextField around() : fieldCreation() {
        JTextField tf = proceed();
        WJTextField wjtf = new WJTextField();
        wjtf.setDocument(tf.getDocument());
        wjtf.setText(tf.getText());
        wjtf.setColumns(tf.getColumns());
        return wjtf;
    }
    
    public static class WJTextField extends JTextField {
        // rien
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.SwingWrappers.WJFrame;

public aspect ColorObserver extends AbstractObserver<RainbowModel, WJFrame>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJFrame o) {
		// TODO Auto-generated method stub
		o.getContentPane().setBackground(s.getColor());
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.ihm;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class Rainbow {
    
    // ATTRIBUTS
    
    public static final int FRAMES_NB = 3;

    private static final int FRAME_WIDTH = 400;
    private static final int FRAME_HEIGHT = 300;
    private static final double[][] POS =
            new double[][] { {-1, -1}, {0, -1}, {-0.5, 0}};

    private JFrame[] frames;
    private JButton[] buttons;
    private JButton[] dingButtons;
    private JTextField[] colors;

    // CONSTRUCTEURS
    
    public Rainbow() {
        createViews();
        placeComponents();
        createControllers();
    }
    
    // REQUETES
    
    public JFrame getFrame(int i) {
        return frames[i];
    }
    
    public JButton getCmd(int i) {
        return buttons[i];
    }
    
    public JButton getDing(int i) {
        return dingButtons[i];
    }
    
    public JTextField getColor(int i) {
        return colors[i];
    }

    // COMMANDES
    
    public void display() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].pack();
            frames[i].setLocation(initLocation(i));
            frames[i].setVisible(true);
        }
    }

    // OUTILS
    
    private void createViews() {
        frames = new JFrame[FRAMES_NB];
        buttons = new JButton[FRAMES_NB];
        dingButtons = new JButton[FRAMES_NB];
        colors = new JTextField[FRAMES_NB];
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i] = new JFrame("Arc-en-ciel " + i);
            frames[i].setPreferredSize(
                    new Dimension(FRAME_WIDTH, FRAME_HEIGHT)
            );
            buttons[i] = new JButton("Modifier");
            dingButtons[i] = new JButton("Ding !");
            colors[i] = new JTextField("");
        }
    }
    
    private void placeComponents() {
        for (int i = 0; i < FRAMES_NB; i++) {
            JPanel p = new JPanel(); {
                p.add(buttons[i]);
                p.add(dingButtons[i]);
            }
            frames[i].add(p, BorderLayout.NORTH);
            p = new JPanel(new GridLayout(1, 0)); {
                p.add(colors[i]);
            }
            frames[i].add(p, BorderLayout.SOUTH);
        }
    }
    
    private void createControllers() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            dingButtons[i].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    Toolkit.getDefaultToolkit().beep();
                }
            });
        }
    }
    
    private Point initLocation(int i) {
        Dimension frameDim = frames[i].getPreferredSize();
        Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();
        Point p = new Point();
        p.x = (int) ((screenDim.width / 2.0) + (POS[i][0] * frameDim.width));
        p.y = (int) ((screenDim.height / 2.0) + (POS[i][1] * frameDim.height));
        return p;
    }
    
    // POINT D'ENTREE

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new Rainbow().display();
            }
        });
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Ce modle permet d'obtenir des couleurs.
 * On peut faire voluer le modle en lui commandant de changer de couleur,
 *  et consulter son tat  tout moment.
 * @inv <pre>
 *     getColor() != null </pre>
 */
public interface RainbowModel {
    
    // REQUETES
    
    /**
     * La couleur courante du modle.
     */
    Color getColor();

    // COMMANDES
    
    /**
     * Modification de l'tat interne.
     * Un appel  cette mthode oblige le modle a changer de couleur.
     * @post <pre>
     *     !getColor().equals(old getColor()) </pre>
     */
    void changeColor();
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

public abstract aspect AbstractObserver<S extends Subject, T extends Observer> extends ObserverProtocol<S, T> {

	public abstract pointcut subjectChange(S s); 
	
	after(S s) : subjectChange(s) {
		notifyObserversFor(s);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import java.awt.Color;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.Observer;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJTextField;

public aspect TextColorObserver extends AbstractObserver<RainbowModel, WJTextField>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJTextField o) {
		// TODO Auto-generated method stub
		Color c = s.getColor();
		o.setText("[" + c.getRed() + "," + c.getGreen()
        + "," + c.getBlue() + "]");
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Notre modle est une squence de couleurs (toutes distinctes) que l'on peut
 *  parcourir cycliquement.
 * Les valeurs de getColor() aprs chaque excution de changeColor() sont
 *  celles obtenues en parcourant cycliquement le tableau COLORS.
 */
public class StdRainbowModel implements RainbowModel {
    
    // ATTRIBUTS
    
    // La squence des diffrentes couleurs gres par le modle
    private static final Color[] COLORS = {
        Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY,
        Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
        Color.PINK, Color.RED, Color.WHITE, Color.YELLOW
    };

    // L'index courant dans le tableau des couleurs
    private int colorIndex;

    // CONSTRUCTEURS
    
    /**
     * Un modle standard, dont la couleur courante est la premire couleur
     *  du tableau.
     */
    public StdRainbowModel() {
        super();
        colorIndex = 0;
    }

    // REQUETES
    
    public Color getColor() {
        return COLORS[colorIndex];
    }

    // COMMANDES
    
    public void changeColor() {
        colorIndex = (colorIndex + 1) % COLORS.length;
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.awt.GraphicsConfiguration;
import java.awt.event.ActionEvent;

import javax.swing.Action;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

public aspect SwingWrappers {
    
    pointcut intoIHM() : within(fiche6.ihm..*);
    
    // fentres tissables
    
    pointcut frameCreation() : call(JFrame.new(..)) && intoIHM();
    
    JFrame around() : frameCreation() {
        JFrame f = proceed();
        return new WJFrame(f.getTitle(), f.getGraphicsConfiguration());
    }
    
    public static class WJFrame extends JFrame {
        public WJFrame(String t, GraphicsConfiguration gc) {
            super(t, gc);
        }
    }

    // champs tissables
    
    pointcut fieldCreation() : call(JTextField.new(..)) && intoIHM();
    
    JTextField around() : fieldCreation() {
        JTextField tf = proceed();
        WJTextField wjtf = new WJTextField();
        wjtf.setDocument(tf.getDocument());
        wjtf.setText(tf.getText());
        wjtf.setColumns(tf.getColumns());
        return wjtf;
    }
    
    public static class WJTextField extends JTextField {
        // rien
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:11749)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12048)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12034)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:357)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12142)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11204)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11490)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:191)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:875)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10179)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 0 2016-12-12 16:19:36.281
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.SwingWrappers.WJFrame;

public aspect ColorObserver extends AbstractObserver<RainbowModel, WJFrame>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJFrame o) {
		// TODO Auto-generated method stub
		o.getContentPane().setBackground(s.getColor());
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.ihm;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class Rainbow {
    
    // ATTRIBUTS
    
    public static final int FRAMES_NB = 3;

    private static final int FRAME_WIDTH = 400;
    private static final int FRAME_HEIGHT = 300;
    private static final double[][] POS =
            new double[][] { {-1, -1}, {0, -1}, {-0.5, 0}};

    private JFrame[] frames;
    private JButton[] buttons;
    private JButton[] dingButtons;
    private JTextField[] colors;

    // CONSTRUCTEURS
    
    public Rainbow() {
        createViews();
        placeComponents();
        createControllers();
    }
    
    // REQUETES
    
    public JFrame getFrame(int i) {
        return frames[i];
    }
    
    public JButton getCmd(int i) {
        return buttons[i];
    }
    
    public JButton getDing(int i) {
        return dingButtons[i];
    }
    
    public JTextField getColor(int i) {
        return colors[i];
    }

    // COMMANDES
    
    public void display() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].pack();
            frames[i].setLocation(initLocation(i));
            frames[i].setVisible(true);
        }
    }

    // OUTILS
    
    private void createViews() {
        frames = new JFrame[FRAMES_NB];
        buttons = new JButton[FRAMES_NB];
        dingButtons = new JButton[FRAMES_NB];
        colors = new JTextField[FRAMES_NB];
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i] = new JFrame("Arc-en-ciel " + i);
            frames[i].setPreferredSize(
                    new Dimension(FRAME_WIDTH, FRAME_HEIGHT)
            );
            buttons[i] = new JButton("Modifier");
            dingButtons[i] = new JButton("Ding !");
            colors[i] = new JTextField("");
        }
    }
    
    private void placeComponents() {
        for (int i = 0; i < FRAMES_NB; i++) {
            JPanel p = new JPanel(); {
                p.add(buttons[i]);
                p.add(dingButtons[i]);
            }
            frames[i].add(p, BorderLayout.NORTH);
            p = new JPanel(new GridLayout(1, 0)); {
                p.add(colors[i]);
            }
            frames[i].add(p, BorderLayout.SOUTH);
        }
    }
    
    private void createControllers() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            dingButtons[i].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    Toolkit.getDefaultToolkit().beep();
                }
            });
        }
    }
    
    private Point initLocation(int i) {
        Dimension frameDim = frames[i].getPreferredSize();
        Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();
        Point p = new Point();
        p.x = (int) ((screenDim.width / 2.0) + (POS[i][0] * frameDim.width));
        p.y = (int) ((screenDim.height / 2.0) + (POS[i][1] * frameDim.height));
        return p;
    }
    
    // POINT D'ENTREE

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new Rainbow().display();
            }
        });
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Ce modle permet d'obtenir des couleurs.
 * On peut faire voluer le modle en lui commandant de changer de couleur,
 *  et consulter son tat  tout moment.
 * @inv <pre>
 *     getColor() != null </pre>
 */
public interface RainbowModel {
    
    // REQUETES
    
    /**
     * La couleur courante du modle.
     */
    Color getColor();

    // COMMANDES
    
    /**
     * Modification de l'tat interne.
     * Un appel  cette mthode oblige le modle a changer de couleur.
     * @post <pre>
     *     !getColor().equals(old getColor()) </pre>
     */
    void changeColor();
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

public abstract aspect AbstractObserver<S extends Subject, T extends Observer> extends ObserverProtocol<S, T> {

	public abstract pointcut subjectChange(S s); 
	
	after(S s) : subjectChange(s) {
		notifyObserversFor(s);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import java.awt.Color;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.Observer;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJTextField;

public aspect TextColorObserver extends AbstractObserver<RainbowModel, WJTextField>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJTextField o) {
		// TODO Auto-generated method stub
		Color c = s.getColor();
		o.setText("[" + c.getRed() + "," + c.getGreen()
        + "," + c.getBlue() + "]");
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Notre modle est une squence de couleurs (toutes distinctes) que l'on peut
 *  parcourir cycliquement.
 * Les valeurs de getColor() aprs chaque excution de changeColor() sont
 *  celles obtenues en parcourant cycliquement le tableau COLORS.
 */
public class StdRainbowModel implements RainbowModel {
    
    // ATTRIBUTS
    
    // La squence des diffrentes couleurs gres par le modle
    private static final Color[] COLORS = {
        Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY,
        Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
        Color.PINK, Color.RED, Color.WHITE, Color.YELLOW
    };

    // L'index courant dans le tableau des couleurs
    private int colorIndex;

    // CONSTRUCTEURS
    
    /**
     * Un modle standard, dont la couleur courante est la premire couleur
     *  du tableau.
     */
    public StdRainbowModel() {
        super();
        colorIndex = 0;
    }

    // REQUETES
    
    public Color getColor() {
        return COLORS[colorIndex];
    }

    // COMMANDES
    
    public void changeColor() {
        colorIndex = (colorIndex + 1) % COLORS.length;
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.awt.GraphicsConfiguration;
import java.awt.event.ActionEvent;

import javax.swing.Action;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

public aspect SwingWrappers {
    
    pointcut intoIHM() : within(fiche6.ihm..*);
    
    // fentres tissables
    
    pointcut frameCreation() : call(JFrame.new(..)) && intoIHM();
    
    JFrame around() : frameCreation() {
        JFrame f = proceed();
        return new WJFrame(f.getTitle(), f.getGraphicsConfiguration());
    }
    
    public static class WJFrame extends JFrame {
        public WJFrame(String t, GraphicsConfiguration gc) {
            super(t, gc);
        }
    }

    // champs tissables
    
    pointcut fieldCreation() : call(JTextField.new(..)) && intoIHM();
    
    JTextField around() : fieldCreation() {
        JTextField tf = proceed();
        WJTextField wjtf = new WJTextField();
        wjtf.setDocument(tf.getDocument());
        wjtf.setText(tf.getText());
        wjtf.setColumns(tf.getColumns());
        return wjtf;
    }
    
    public static class WJTextField extends JTextField {
        // rien
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.SwingWrappers.WJFrame;

public aspect ColorObserver extends AbstractObserver<RainbowModel, WJFrame>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJFrame o) {
		// TODO Auto-generated method stub
		o.getContentPane().setBackground(s.getColor());
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.ihm;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class Rainbow {
    
    // ATTRIBUTS
    
    public static final int FRAMES_NB = 3;

    private static final int FRAME_WIDTH = 400;
    private static final int FRAME_HEIGHT = 300;
    private static final double[][] POS =
            new double[][] { {-1, -1}, {0, -1}, {-0.5, 0}};

    private JFrame[] frames;
    private JButton[] buttons;
    private JButton[] dingButtons;
    private JTextField[] colors;

    // CONSTRUCTEURS
    
    public Rainbow() {
        createViews();
        placeComponents();
        createControllers();
    }
    
    // REQUETES
    
    public JFrame getFrame(int i) {
        return frames[i];
    }
    
    public JButton getCmd(int i) {
        return buttons[i];
    }
    
    public JButton getDing(int i) {
        return dingButtons[i];
    }
    
    public JTextField getColor(int i) {
        return colors[i];
    }

    // COMMANDES
    
    public void display() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].pack();
            frames[i].setLocation(initLocation(i));
            frames[i].setVisible(true);
        }
    }

    // OUTILS
    
    private void createViews() {
        frames = new JFrame[FRAMES_NB];
        buttons = new JButton[FRAMES_NB];
        dingButtons = new JButton[FRAMES_NB];
        colors = new JTextField[FRAMES_NB];
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i] = new JFrame("Arc-en-ciel " + i);
            frames[i].setPreferredSize(
                    new Dimension(FRAME_WIDTH, FRAME_HEIGHT)
            );
            buttons[i] = new JButton("Modifier");
            dingButtons[i] = new JButton("Ding !");
            colors[i] = new JTextField("");
        }
    }
    
    private void placeComponents() {
        for (int i = 0; i < FRAMES_NB; i++) {
            JPanel p = new JPanel(); {
                p.add(buttons[i]);
                p.add(dingButtons[i]);
            }
            frames[i].add(p, BorderLayout.NORTH);
            p = new JPanel(new GridLayout(1, 0)); {
                p.add(colors[i]);
            }
            frames[i].add(p, BorderLayout.SOUTH);
        }
    }
    
    private void createControllers() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            dingButtons[i].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    Toolkit.getDefaultToolkit().beep();
                }
            });
        }
    }
    
    private Point initLocation(int i) {
        Dimension frameDim = frames[i].getPreferredSize();
        Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();
        Point p = new Point();
        p.x = (int) ((screenDim.width / 2.0) + (POS[i][0] * frameDim.width));
        p.y = (int) ((screenDim.height / 2.0) + (POS[i][1] * frameDim.height));
        return p;
    }
    
    // POINT D'ENTREE

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new Rainbow().display();
            }
        });
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Ce modle permet d'obtenir des couleurs.
 * On peut faire voluer le modle en lui commandant de changer de couleur,
 *  et consulter son tat  tout moment.
 * @inv <pre>
 *     getColor() != null </pre>
 */
public interface RainbowModel {
    
    // REQUETES
    
    /**
     * La couleur courante du modle.
     */
    Color getColor();

    // COMMANDES
    
    /**
     * Modification de l'tat interne.
     * Un appel  cette mthode oblige le modle a changer de couleur.
     * @post <pre>
     *     !getColor().equals(old getColor()) </pre>
     */
    void changeColor();
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

public abstract aspect AbstractObserver<S extends Subject, T extends Observer> extends ObserverProtocol<S, T> {

	public abstract pointcut subjectChange(S s); 
	
	after(S s) : subjectChange(s) {
		notifyObserversFor(s);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import java.awt.Color;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.Observer;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJTextField;

public aspect TextColorObserver extends AbstractObserver<RainbowModel, WJTextField>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJTextField o) {
		// TODO Auto-generated method stub
		Color c = s.getColor();
		o.setText("[" + c.getRed() + "," + c.getGreen()
        + "," + c.getBlue() + "]");
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Notre modle est une squence de couleurs (toutes distinctes) que l'on peut
 *  parcourir cycliquement.
 * Les valeurs de getColor() aprs chaque excution de changeColor() sont
 *  celles obtenues en parcourant cycliquement le tableau COLORS.
 */
public class StdRainbowModel implements RainbowModel {
    
    // ATTRIBUTS
    
    // La squence des diffrentes couleurs gres par le modle
    private static final Color[] COLORS = {
        Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY,
        Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
        Color.PINK, Color.RED, Color.WHITE, Color.YELLOW
    };

    // L'index courant dans le tableau des couleurs
    private int colorIndex;

    // CONSTRUCTEURS
    
    /**
     * Un modle standard, dont la couleur courante est la premire couleur
     *  du tableau.
     */
    public StdRainbowModel() {
        super();
        colorIndex = 0;
    }

    // REQUETES
    
    public Color getColor() {
        return COLORS[colorIndex];
    }

    // COMMANDES
    
    public void changeColor() {
        colorIndex = (colorIndex + 1) % COLORS.length;
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.awt.GraphicsConfiguration;
import java.awt.event.ActionEvent;

import javax.swing.Action;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

public aspect SwingWrappers {
    
    pointcut intoIHM() : within(fiche6.ihm..*);
    
    // fentres tissables
    
    pointcut frameCreation() : call(JFrame.new(..)) && intoIHM();
    
    JFrame around() : frameCreation() {
        JFrame f = proceed();
        return new WJFrame(f.getTitle(), f.getGraphicsConfiguration());
    }
    
    public static class WJFrame extends JFrame {
        public WJFrame(String t, GraphicsConfiguration gc) {
            super(t, gc);
        }
    }

    // champs tissables
    
    pointcut fieldCreation() : call(JTextField.new(..)) && intoIHM();
    
    JTextField around() : fieldCreation() {
        JTextField tf = proceed();
        WJTextField wjtf = new WJTextField();
        wjtf.setDocument(tf.getDocument());
        wjtf.setText(tf.getText());
        wjtf.setColumns(tf.getColumns());
        return wjtf;
    }
    
    public static class WJTextField extends JTextField {
        // rien
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:11749)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12048)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12034)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:357)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12142)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11204)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11490)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:191)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:875)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10179)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.SwingWrappers.WJFrame;

public aspect ColorObserver extends AbstractObserver<RainbowModel, WJFrame>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJFrame o) {
		// TODO Auto-generated method stub
		o.getContentPane().setBackground(s.getColor());
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.ihm;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class Rainbow {
    
    // ATTRIBUTS
    
    public static final int FRAMES_NB = 3;

    private static final int FRAME_WIDTH = 400;
    private static final int FRAME_HEIGHT = 300;
    private static final double[][] POS =
            new double[][] { {-1, -1}, {0, -1}, {-0.5, 0}};

    private JFrame[] frames;
    private JButton[] buttons;
    private JButton[] dingButtons;
    private JTextField[] colors;

    // CONSTRUCTEURS
    
    public Rainbow() {
        createViews();
        placeComponents();
        createControllers();
    }
    
    // REQUETES
    
    public JFrame getFrame(int i) {
        return frames[i];
    }
    
    public JButton getCmd(int i) {
        return buttons[i];
    }
    
    public JButton getDing(int i) {
        return dingButtons[i];
    }
    
    public JTextField getColor(int i) {
        return colors[i];
    }

    // COMMANDES
    
    public void display() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].pack();
            frames[i].setLocation(initLocation(i));
            frames[i].setVisible(true);
        }
    }

    // OUTILS
    
    private void createViews() {
        frames = new JFrame[FRAMES_NB];
        buttons = new JButton[FRAMES_NB];
        dingButtons = new JButton[FRAMES_NB];
        colors = new JTextField[FRAMES_NB];
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i] = new JFrame("Arc-en-ciel " + i);
            frames[i].setPreferredSize(
                    new Dimension(FRAME_WIDTH, FRAME_HEIGHT)
            );
            buttons[i] = new JButton("Modifier");
            dingButtons[i] = new JButton("Ding !");
            colors[i] = new JTextField("");
        }
    }
    
    private void placeComponents() {
        for (int i = 0; i < FRAMES_NB; i++) {
            JPanel p = new JPanel(); {
                p.add(buttons[i]);
                p.add(dingButtons[i]);
            }
            frames[i].add(p, BorderLayout.NORTH);
            p = new JPanel(new GridLayout(1, 0)); {
                p.add(colors[i]);
            }
            frames[i].add(p, BorderLayout.SOUTH);
        }
    }
    
    private void createControllers() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            dingButtons[i].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    Toolkit.getDefaultToolkit().beep();
                }
            });
        }
    }
    
    private Point initLocation(int i) {
        Dimension frameDim = frames[i].getPreferredSize();
        Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();
        Point p = new Point();
        p.x = (int) ((screenDim.width / 2.0) + (POS[i][0] * frameDim.width));
        p.y = (int) ((screenDim.height / 2.0) + (POS[i][1] * frameDim.height));
        return p;
    }
    
    // POINT D'ENTREE

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new Rainbow().display();
            }
        });
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Ce modle permet d'obtenir des couleurs.
 * On peut faire voluer le modle en lui commandant de changer de couleur,
 *  et consulter son tat  tout moment.
 * @inv <pre>
 *     getColor() != null </pre>
 */
public interface RainbowModel {
    
    // REQUETES
    
    /**
     * La couleur courante du modle.
     */
    Color getColor();

    // COMMANDES
    
    /**
     * Modification de l'tat interne.
     * Un appel  cette mthode oblige le modle a changer de couleur.
     * @post <pre>
     *     !getColor().equals(old getColor()) </pre>
     */
    void changeColor();
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

public abstract aspect AbstractObserver<S extends Subject, T extends Observer> extends ObserverProtocol<S, T> {

	public abstract pointcut subjectChange(S s); 
	
	after(S s) : subjectChange(s) {
		notifyObserversFor(s);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import java.awt.Color;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.Observer;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJTextField;

public aspect TextColorObserver extends AbstractObserver<RainbowModel, WJTextField>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJTextField o) {
		// TODO Auto-generated method stub
		Color c = s.getColor();
		o.setText("[" + c.getRed() + "," + c.getGreen()
        + "," + c.getBlue() + "]");
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Notre modle est une squence de couleurs (toutes distinctes) que l'on peut
 *  parcourir cycliquement.
 * Les valeurs de getColor() aprs chaque excution de changeColor() sont
 *  celles obtenues en parcourant cycliquement le tableau COLORS.
 */
public class StdRainbowModel implements RainbowModel {
    
    // ATTRIBUTS
    
    // La squence des diffrentes couleurs gres par le modle
    private static final Color[] COLORS = {
        Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY,
        Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
        Color.PINK, Color.RED, Color.WHITE, Color.YELLOW
    };

    // L'index courant dans le tableau des couleurs
    private int colorIndex;

    // CONSTRUCTEURS
    
    /**
     * Un modle standard, dont la couleur courante est la premire couleur
     *  du tableau.
     */
    public StdRainbowModel() {
        super();
        colorIndex = 0;
    }

    // REQUETES
    
    public Color getColor() {
        return COLORS[colorIndex];
    }

    // COMMANDES
    
    public void changeColor() {
        colorIndex = (colorIndex + 1) % COLORS.length;
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.awt.GraphicsConfiguration;
import java.awt.event.ActionEvent;

import javax.swing.Action;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

public aspect SwingWrappers {
    
    pointcut intoIHM() : within(fiche6.ihm..*);
    
    // fentres tissables
    
    pointcut frameCreation() : call(JFrame.new(..)) && intoIHM();
    
    JFrame around() : frameCreation() {
        JFrame f = proceed();
        return new WJFrame(f.getTitle(), f.getGraphicsConfiguration());
    }
    
    public static class WJFrame extends JFrame {
        public WJFrame(String t, GraphicsConfiguration gc) {
            super(t, gc);
        }
    }

    // champs tissables
    
    pointcut fieldCreation() : call(JTextField.new(..)) && intoIHM();
    
    JTextField around() : fieldCreation() {
        JTextField tf = proceed();
        WJTextField wjtf = new WJTextField();
        wjtf.setDocument(tf.getDocument());
        wjtf.setText(tf.getText());
        wjtf.setColumns(tf.getColumns());
        return wjtf;
    }
    
    public static class WJTextField extends JTextField {
        // rien
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:11749)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12048)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12034)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:357)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12142)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11204)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11490)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:191)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:875)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10179)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2016-12-12 16:19:36.281
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.SwingWrappers.WJFrame;

public aspect ColorObserver extends AbstractObserver<RainbowModel, WJFrame>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJFrame o) {
		// TODO Auto-generated method stub
		o.getContentPane().setBackground(s.getColor());
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.ihm;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class Rainbow {
    
    // ATTRIBUTS
    
    public static final int FRAMES_NB = 3;

    private static final int FRAME_WIDTH = 400;
    private static final int FRAME_HEIGHT = 300;
    private static final double[][] POS =
            new double[][] { {-1, -1}, {0, -1}, {-0.5, 0}};

    private JFrame[] frames;
    private JButton[] buttons;
    private JButton[] dingButtons;
    private JTextField[] colors;

    // CONSTRUCTEURS
    
    public Rainbow() {
        createViews();
        placeComponents();
        createControllers();
    }
    
    // REQUETES
    
    public JFrame getFrame(int i) {
        return frames[i];
    }
    
    public JButton getCmd(int i) {
        return buttons[i];
    }
    
    public JButton getDing(int i) {
        return dingButtons[i];
    }
    
    public JTextField getColor(int i) {
        return colors[i];
    }

    // COMMANDES
    
    public void display() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].pack();
            frames[i].setLocation(initLocation(i));
            frames[i].setVisible(true);
        }
    }

    // OUTILS
    
    private void createViews() {
        frames = new JFrame[FRAMES_NB];
        buttons = new JButton[FRAMES_NB];
        dingButtons = new JButton[FRAMES_NB];
        colors = new JTextField[FRAMES_NB];
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i] = new JFrame("Arc-en-ciel " + i);
            frames[i].setPreferredSize(
                    new Dimension(FRAME_WIDTH, FRAME_HEIGHT)
            );
            buttons[i] = new JButton("Modifier");
            dingButtons[i] = new JButton("Ding !");
            colors[i] = new JTextField("");
        }
    }
    
    private void placeComponents() {
        for (int i = 0; i < FRAMES_NB; i++) {
            JPanel p = new JPanel(); {
                p.add(buttons[i]);
                p.add(dingButtons[i]);
            }
            frames[i].add(p, BorderLayout.NORTH);
            p = new JPanel(new GridLayout(1, 0)); {
                p.add(colors[i]);
            }
            frames[i].add(p, BorderLayout.SOUTH);
        }
    }
    
    private void createControllers() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            dingButtons[i].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    Toolkit.getDefaultToolkit().beep();
                }
            });
        }
    }
    
    private Point initLocation(int i) {
        Dimension frameDim = frames[i].getPreferredSize();
        Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();
        Point p = new Point();
        p.x = (int) ((screenDim.width / 2.0) + (POS[i][0] * frameDim.width));
        p.y = (int) ((screenDim.height / 2.0) + (POS[i][1] * frameDim.height));
        return p;
    }
    
    // POINT D'ENTREE

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new Rainbow().display();
            }
        });
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Ce modle permet d'obtenir des couleurs.
 * On peut faire voluer le modle en lui commandant de changer de couleur,
 *  et consulter son tat  tout moment.
 * @inv <pre>
 *     getColor() != null </pre>
 */
public interface RainbowModel {
    
    // REQUETES
    
    /**
     * La couleur courante du modle.
     */
    Color getColor();

    // COMMANDES
    
    /**
     * Modification de l'tat interne.
     * Un appel  cette mthode oblige le modle a changer de couleur.
     * @post <pre>
     *     !getColor().equals(old getColor()) </pre>
     */
    void changeColor();
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

public abstract aspect AbstractObserver<S extends Subject, T extends Observer> extends ObserverProtocol<S, T> {

	public abstract pointcut subjectChange(S s); 
	
	after(S s) : subjectChange(s) {
		notifyObserversFor(s);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import java.awt.Color;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.Observer;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJTextField;

public aspect TextColorObserver extends AbstractObserver<RainbowModel, WJTextField>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJTextField o) {
		// TODO Auto-generated method stub
		Color c = s.getColor();
		o.setText("[" + c.getRed() + "," + c.getGreen()
        + "," + c.getBlue() + "]");
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Notre modle est une squence de couleurs (toutes distinctes) que l'on peut
 *  parcourir cycliquement.
 * Les valeurs de getColor() aprs chaque excution de changeColor() sont
 *  celles obtenues en parcourant cycliquement le tableau COLORS.
 */
public class StdRainbowModel implements RainbowModel {
    
    // ATTRIBUTS
    
    // La squence des diffrentes couleurs gres par le modle
    private static final Color[] COLORS = {
        Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY,
        Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
        Color.PINK, Color.RED, Color.WHITE, Color.YELLOW
    };

    // L'index courant dans le tableau des couleurs
    private int colorIndex;

    // CONSTRUCTEURS
    
    /**
     * Un modle standard, dont la couleur courante est la premire couleur
     *  du tableau.
     */
    public StdRainbowModel() {
        super();
        colorIndex = 0;
    }

    // REQUETES
    
    public Color getColor() {
        return COLORS[colorIndex];
    }

    // COMMANDES
    
    public void changeColor() {
        colorIndex = (colorIndex + 1) % COLORS.length;
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.awt.GraphicsConfiguration;
import java.awt.event.ActionEvent;

import javax.swing.Action;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

public aspect SwingWrappers {
    
    pointcut intoIHM() : within(fiche6.ihm..*);
    
    // fentres tissables
    
    pointcut frameCreation() : call(JFrame.new(..)) && intoIHM();
    
    JFrame around() : frameCreation() {
        JFrame f = proceed();
        return new WJFrame(f.getTitle(), f.getGraphicsConfiguration());
    }
    
    public static class WJFrame extends JFrame {
        public WJFrame(String t, GraphicsConfiguration gc) {
            super(t, gc);
        }
    }

    // champs tissables
    
    pointcut fieldCreation() : call(JTextField.new(..)) && intoIHM();
    
    JTextField around() : fieldCreation() {
        JTextField tf = proceed();
        WJTextField wjtf = new WJTextField();
        wjtf.setDocument(tf.getDocument());
        wjtf.setText(tf.getText());
        wjtf.setColumns(tf.getColumns());
        return wjtf;
    }
    
    public static class WJTextField extends JTextField {
        // rien
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.SwingWrappers.WJFrame;

public aspect ColorObserver extends AbstractObserver<RainbowModel, WJFrame>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJFrame o) {
		// TODO Auto-generated method stub
		o.getContentPane().setBackground(s.getColor());
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.ihm;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class Rainbow {
    
    // ATTRIBUTS
    
    public static final int FRAMES_NB = 3;

    private static final int FRAME_WIDTH = 400;
    private static final int FRAME_HEIGHT = 300;
    private static final double[][] POS =
            new double[][] { {-1, -1}, {0, -1}, {-0.5, 0}};

    private JFrame[] frames;
    private JButton[] buttons;
    private JButton[] dingButtons;
    private JTextField[] colors;

    // CONSTRUCTEURS
    
    public Rainbow() {
        createViews();
        placeComponents();
        createControllers();
    }
    
    // REQUETES
    
    public JFrame getFrame(int i) {
        return frames[i];
    }
    
    public JButton getCmd(int i) {
        return buttons[i];
    }
    
    public JButton getDing(int i) {
        return dingButtons[i];
    }
    
    public JTextField getColor(int i) {
        return colors[i];
    }

    // COMMANDES
    
    public void display() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].pack();
            frames[i].setLocation(initLocation(i));
            frames[i].setVisible(true);
        }
    }

    // OUTILS
    
    private void createViews() {
        frames = new JFrame[FRAMES_NB];
        buttons = new JButton[FRAMES_NB];
        dingButtons = new JButton[FRAMES_NB];
        colors = new JTextField[FRAMES_NB];
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i] = new JFrame("Arc-en-ciel " + i);
            frames[i].setPreferredSize(
                    new Dimension(FRAME_WIDTH, FRAME_HEIGHT)
            );
            buttons[i] = new JButton("Modifier");
            dingButtons[i] = new JButton("Ding !");
            colors[i] = new JTextField("");
        }
    }
    
    private void placeComponents() {
        for (int i = 0; i < FRAMES_NB; i++) {
            JPanel p = new JPanel(); {
                p.add(buttons[i]);
                p.add(dingButtons[i]);
            }
            frames[i].add(p, BorderLayout.NORTH);
            p = new JPanel(new GridLayout(1, 0)); {
                p.add(colors[i]);
            }
            frames[i].add(p, BorderLayout.SOUTH);
        }
    }
    
    private void createControllers() {
        for (int i = 0; i < FRAMES_NB; i++) {
            frames[i].setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            dingButtons[i].addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    Toolkit.getDefaultToolkit().beep();
                }
            });
        }
    }
    
    private Point initLocation(int i) {
        Dimension frameDim = frames[i].getPreferredSize();
        Dimension screenDim = Toolkit.getDefaultToolkit().getScreenSize();
        Point p = new Point();
        p.x = (int) ((screenDim.width / 2.0) + (POS[i][0] * frameDim.width));
        p.y = (int) ((screenDim.height / 2.0) + (POS[i][1] * frameDim.height));
        return p;
    }
    
    // POINT D'ENTREE

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new Rainbow().display();
            }
        });
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Ce modle permet d'obtenir des couleurs.
 * On peut faire voluer le modle en lui commandant de changer de couleur,
 *  et consulter son tat  tout moment.
 * @inv <pre>
 *     getColor() != null </pre>
 */
public interface RainbowModel {
    
    // REQUETES
    
    /**
     * La couleur courante du modle.
     */
    Color getColor();

    // COMMANDES
    
    /**
     * Modification de l'tat interne.
     * Un appel  cette mthode oblige le modle a changer de couleur.
     * @post <pre>
     *     !getColor().equals(old getColor()) </pre>
     */
    void changeColor();
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

public abstract aspect AbstractObserver<S extends Subject, T extends Observer> extends ObserverProtocol<S, T> {

	public abstract pointcut subjectChange(S s); 
	
	after(S s) : subjectChange(s) {
		notifyObserversFor(s);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;


public abstract class ObserverProtocol<S extends Subject, T extends Observer> {
    
    // ATTRIBUTS
    
    /**
     * Table associative contenant toutes les relations entre sujets et
     *  observateurs pour une mme ralisation du patron Observer.
     * Tous les sujets et tous les observateurs stocks dans cette table sont
     *  distincts de null.
     */
    private Map<S, List<T>> perSubjectObservers;

    // COMMANDES
    
    /**
     * Ajoute une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs != null && obs.contains(o)
     */
    public void addObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
        	if (perSubjectObservers == null) {
        		perSubjectObservers= new WeakHashMap<S, List<T>>();
        	}
        	
        	List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers == null) {
        		observers = new LinkedList<T>();
        		perSubjectObservers.put(s, observers);
        	}
        	observers.add(o);	
    	}
    }
    
    
    /**
     * Supprime une association sujet-observateur.
     * @pre
     *     s != null && o != null
     * @post
     *     Let obs ::= perSubjectObservers.get(s)
     *         obs == null || !obs.contains(o)
     */
    public void removeObserver(S s, T o) {
        /***************/
        /*   A FAIRE   */
        /***************/
    	if (s!= null && o != null) {
    		List<T> observers = (LinkedList<T>) perSubjectObservers.get(s);
        	
        	if (observers != null) {
        		observers.remove(o);
        	}
    	}
    }
    
    /**
     * Notifie tous les observateurs de tous les sujets de la table associative.
     */
    public void notifyObservers() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	for (S s : perSubjectObservers.keySet()) {
    		notifyObserversFor(s);
    	}
    }
    
    /**
     * Notifie tous les observateurs de s pralablement enregistrs.
     * @post
     *     updateObserver(s, o) a t excute pour chaque observateur o de s
     */
    protected void notifyObserversFor(S s) {
        /***************/
        /*   A FAIRE   */
        /***************/
		Iterator<T> iter = perSubjectObservers.get(s).iterator();
		while(iter.hasNext()) {
			updateObserver(s, iter.next());
		}
    }
    
    /**
     * Dfinit le comportement d'observation de o sur s pour une ralisation du
     *  patron Observer.
     */
    protected abstract void updateObserver(S s, T o);

    // OUTILS
    
    /**
     * Retourne l'ensemble des sujets rfrencs par la table associative.
     * @post
     *     result != null
     */
    private Set<S> getSubjects() {
        /***************/
        /*   A FAIRE   */
        /***************/
    	return perSubjectObservers.keySet();
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import javax.swing.JFrame;

import fiche6.domain.RainbowModel;
import fiche6.domain.StdRainbowModel;
import fiche6.ihm.Rainbow;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJFrame;
import fiche6.util.SwingWrappers.WJTextField;

public aspect RainbowConfigurator {

	declare parents : fiche6.domain.RainbowModel extends fiche6.util.Subject;
	declare parents : fiche6.util.SwingWrappers.WJFrame extends fiche6.util.Observer;
	declare parents : fiche6.util.SwingWrappers.WJTextField extends fiche6.util.Observer;

	pointcut constructorRainbowCalled(Rainbow r): this(r) && execution(fiche6.ihm.Rainbow.new(..));
	
	RainbowModel[] models;

	private void createModels() {
		models = new StdRainbowModel[2];
		for (int i = 0; i < models.length; i++) {
			models[i] = new StdRainbowModel();
		}
	}
	
	after(Rainbow r) : constructorRainbowCalled(r) {
		createModels();
		createControllers(r);
		
		ColorObserver.aspectOf().notifyObservers();
		TextColorObserver.aspectOf().notifyObservers();
	}
	
	private void createControllers(Rainbow r) {
		RainbowModel[] tabModel = {models[0], models[0], models[1]};
		for(int i RainbowModel model : tabModel) {
			
		}
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(0));
		ColorObserver.aspectOf().addObserver(models[0], (WJFrame) r.getFrame(1));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(0));
		TextColorObserver.aspectOf().addObserver(models[0], (WJTextField) r.getColor(1));
		ColorObserver.aspectOf().addObserver(models[1], (WJFrame) r.getFrame(2));
		TextColorObserver.aspectOf().addObserver(models[1], (WJTextField) r.getColor(2));
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.controller;

import java.awt.Color;

import fiche6.domain.RainbowModel;
import fiche6.util.AbstractObserver;
import fiche6.util.Observer;
import fiche6.util.Subject;
import fiche6.util.SwingWrappers.WJTextField;

public aspect TextColorObserver extends AbstractObserver<RainbowModel, WJTextField>{

	public pointcut subjectChange(RainbowModel s) : target(s) && call(void fiche6.domain.StdRainbowModel.changeColor(..)); 
	
	@Override
	protected void updateObserver(RainbowModel s, WJTextField o) {
		// TODO Auto-generated method stub
		Color c = s.getColor();
		o.setText("[" + c.getRed() + "," + c.getGreen()
        + "," + c.getBlue() + "]");
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.domain;

import java.awt.Color;

/**
 * Notre modle est une squence de couleurs (toutes distinctes) que l'on peut
 *  parcourir cycliquement.
 * Les valeurs de getColor() aprs chaque excution de changeColor() sont
 *  celles obtenues en parcourant cycliquement le tableau COLORS.
 */
public class StdRainbowModel implements RainbowModel {
    
    // ATTRIBUTS
    
    // La squence des diffrentes couleurs gres par le modle
    private static final Color[] COLORS = {
        Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY,
        Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
        Color.PINK, Color.RED, Color.WHITE, Color.YELLOW
    };

    // L'index courant dans le tableau des couleurs
    private int colorIndex;

    // CONSTRUCTEURS
    
    /**
     * Un modle standard, dont la couleur courante est la premire couleur
     *  du tableau.
     */
    public StdRainbowModel() {
        super();
        colorIndex = 0;
    }

    // REQUETES
    
    public Color getColor() {
        return COLORS[colorIndex];
    }

    // COMMANDES
    
    public void changeColor() {
        colorIndex = (colorIndex + 1) % COLORS.length;
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package fiche6.util;

import java.awt.GraphicsConfiguration;
import java.awt.event.ActionEvent;

import javax.swing.Action;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

public aspect SwingWrappers {
    
    pointcut intoIHM() : within(fiche6.ihm..*);
    
    // fentres tissables
    
    pointcut frameCreation() : call(JFrame.new(..)) && intoIHM();
    
    JFrame around() : frameCreation() {
        JFrame f = proceed();
        return new WJFrame(f.getTitle(), f.getGraphicsConfiguration());
    }
    
    public static class WJFrame extends JFrame {
        public WJFrame(String t, GraphicsConfiguration gc) {
            super(t, gc);
        }
    }

    // champs tissables
    
    pointcut fieldCreation() : call(JTextField.new(..)) && intoIHM();
    
    JTextField around() : fieldCreation() {
        JTextField tf = proceed();
        WJTextField wjtf = new WJTextField();
        wjtf.setDocument(tf.getDocument());
        wjtf.setText(tf.getText());
        wjtf.setColumns(tf.getColumns());
        return wjtf;
    }
    
    public static class WJTextField extends JTextField {
        // rien
    }
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6111)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11141)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:11749)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12048)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12034)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:357)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12142)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11204)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11490)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:191)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:875)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10179)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.mylyn.tasks.core 4 0 2016-12-12 16:32:32.445
!MESSAGE Notification failed for: org.eclipse.mylyn.internal.tasks.core.TaskActivityManager$1@385a8926
!STACK 0
org.eclipse.swt.SWTException: Device is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4533)
	at org.eclipse.swt.SWT.error(SWT.java:4448)
	at org.eclipse.swt.SWT.error(SWT.java:4419)
	at org.eclipse.swt.widgets.Display.error(Display.java:1236)
	at org.eclipse.swt.widgets.Display.asyncExec(Display.java:775)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListView$2.activityReset(TaskListView.java:343)
	at org.eclipse.mylyn.internal.tasks.core.TaskActivityManager.reloadPlanningData(TaskActivityManager.java:211)
	at org.eclipse.mylyn.internal.tasks.core.TaskActivityManager$1.containersChanged(TaskActivityManager.java:95)
	at org.eclipse.mylyn.internal.tasks.core.TaskList.fireDelta(TaskList.java:273)
	at org.eclipse.mylyn.internal.tasks.core.TaskList.notifyElementsChanged(TaskList.java:495)
	at org.eclipse.mylyn.internal.tasks.core.TaskJobFactory$1.done(TaskJobFactory.java:140)
	at org.eclipse.core.internal.jobs.JobListeners$3.notify(JobListeners.java:42)
	at org.eclipse.core.internal.jobs.JobListeners.doNotify(JobListeners.java:106)
	at org.eclipse.core.internal.jobs.JobListeners.done(JobListeners.java:144)
	at org.eclipse.core.internal.jobs.JobManager.cancel(JobManager.java:346)
	at org.eclipse.core.internal.jobs.JobManager.cancel(JobManager.java:354)
	at org.eclipse.mylyn.internal.tasks.ui.TasksUiPlugin.stop(TasksUiPlugin.java:797)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$4.run(BundleContextImpl.java:830)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$4.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.stop(BundleContextImpl.java:823)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.stopWorker0(EquinoxBundle.java:946)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.stopWorker(EquinoxBundle.java:314)
	at org.eclipse.osgi.container.Module.doStop(Module.java:636)
	at org.eclipse.osgi.container.Module.stop(Module.java:498)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.decStartLevel(ModuleContainer.java:1661)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1580)
	at org.eclipse.osgi.container.SystemModule.stopWorker(SystemModule.java:270)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$SystemBundle$EquinoxSystemModule.stopWorker(EquinoxBundle.java:147)
	at org.eclipse.osgi.container.Module.doStop(Module.java:636)
	at org.eclipse.osgi.container.Module.stop(Module.java:498)
	at org.eclipse.osgi.container.SystemModule.stop(SystemModule.java:202)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$SystemBundle$EquinoxSystemModule$1.run(EquinoxBundle.java:165)
	at java.lang.Thread.run(Thread.java:745)

!ENTRY org.eclipse.mylyn.tasks.core 4 0 2016-12-12 16:32:32.446
!MESSAGE Notification failed for: org.eclipse.mylyn.internal.tasks.ui.views.TaskListRefreshJob$1@2c778e06
!STACK 0
org.eclipse.swt.SWTException: Device is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4533)
	at org.eclipse.swt.SWT.error(SWT.java:4448)
	at org.eclipse.swt.SWT.error(SWT.java:4419)
	at org.eclipse.swt.widgets.Display.error(Display.java:1236)
	at org.eclipse.swt.widgets.Display.asyncExec(Display.java:775)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListRefreshJob$1.containersChanged(TaskListRefreshJob.java:50)
	at org.eclipse.mylyn.internal.tasks.core.TaskList.fireDelta(TaskList.java:273)
	at org.eclipse.mylyn.internal.tasks.core.TaskList.notifyElementsChanged(TaskList.java:495)
	at org.eclipse.mylyn.internal.tasks.core.TaskJobFactory$1.done(TaskJobFactory.java:140)
	at org.eclipse.core.internal.jobs.JobListeners$3.notify(JobListeners.java:42)
	at org.eclipse.core.internal.jobs.JobListeners.doNotify(JobListeners.java:106)
	at org.eclipse.core.internal.jobs.JobListeners.done(JobListeners.java:144)
	at org.eclipse.core.internal.jobs.JobManager.cancel(JobManager.java:346)
	at org.eclipse.core.internal.jobs.JobManager.cancel(JobManager.java:354)
	at org.eclipse.mylyn.internal.tasks.ui.TasksUiPlugin.stop(TasksUiPlugin.java:797)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$4.run(BundleContextImpl.java:830)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$4.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.stop(BundleContextImpl.java:823)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.stopWorker0(EquinoxBundle.java:946)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.stopWorker(EquinoxBundle.java:314)
	at org.eclipse.osgi.container.Module.doStop(Module.java:636)
	at org.eclipse.osgi.container.Module.stop(Module.java:498)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.decStartLevel(ModuleContainer.java:1661)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1580)
	at org.eclipse.osgi.container.SystemModule.stopWorker(SystemModule.java:270)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$SystemBundle$EquinoxSystemModule.stopWorker(EquinoxBundle.java:147)
	at org.eclipse.osgi.container.Module.doStop(Module.java:636)
	at org.eclipse.osgi.container.Module.stop(Module.java:498)
	at org.eclipse.osgi.container.SystemModule.stop(SystemModule.java:202)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$SystemBundle$EquinoxSystemModule$1.run(EquinoxBundle.java:165)
	at java.lang.Thread.run(Thread.java:745)
